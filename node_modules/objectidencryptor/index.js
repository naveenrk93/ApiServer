'use strict';

var crypto = require('crypto'),
    hexConverter = require('./lib/hex-converter'),
    base32 = require('./lib/base32'),
    base32Twisted = require('./lib/base32-twisted'),
    crc16 = require('./lib/crc-16'),
    nconf = require('nconf');

var ALGORITHM = 'desx-cbc',
    HASH_ALGORITHM = 'sha1',
    BLOCK_SIZE = 8;

/**
 * Function - encrypt
 * Encrypt a given object id string into the 13, 16 (CRC), or 17(Twisted) character encrypted format.
 * @param data - The object id to encrypt.
 * @param config - A configuration object for the encryptor.
 * @param config.key - (optional) The key as a string of text. If this is not defined, keyName must be defined.
 * @param config.iv - (optional) The iv as a string of text. If this is not defined, ivName must be defined.
 * @param config.keyName - (optional) The name of the vault property from which to retrieve the key.
 * @param config.ivName - (optional) The name of the vault property from which to retrieve the iv.
 * @param config.type - The type of encoding to use. This can be 'PLAIN', 'PLAIN_WITH_CRC', or 'TWISTED'.
 *
 * @return A string representing the encrypted object id.
 **/
module.exports.encrypt = function(data, config) {
    var key,
        iv,
        cipher,
        output,
        inData,
        protectedKeys = nconf.get('vault:keys'),
        buffBaseSize,
        offset;

    data = '' + data;

    data = hexConverter.decToHex(data);
    buffBaseSize = (parseInt(data.length / (BLOCK_SIZE * 2)) * BLOCK_SIZE);
    offset = (BLOCK_SIZE - (parseInt(data.length / 2) % BLOCK_SIZE)) % BLOCK_SIZE;
    inData = new Buffer(buffBaseSize + (offset ? BLOCK_SIZE : 0));
    inData.fill(0x00);
    inData.write(data, offset, 'hex');

    if (config.key) {
        key = getDesxKey(config.key);
    } else {
        key = getDesxKey((new Buffer(protectedKeys[config.keyName], 'base64')).toString('utf8'));
    }

    if (config.iv) {
        iv = getIV(config.iv);
    } else {
        iv = getIV((new Buffer(protectedKeys[config.ivName], 'base64')).toString('utf8'));
    }

    cipher = crypto.createCipheriv(ALGORITHM, key, iv);
    cipher.setAutoPadding(false);

    output = cipher.update(inData);
    output = Buffer.concat([output, cipher.final()]);
    output = encode(output, config.type);

    return output;
};

/**
 * Function - decrypt
 * decrypt a given encrypted object id string from the 13, 16 (CRC), or 17(Twisted) character encrypted format.
 * @param data - The encrypted object id to decrypt.
 * @param config - A configuration object for the decrypter.
 * @param config.key - (optional) The key as a string of text. If this is not defined, keyName must be defined.
 * @param config.iv - (optional) The iv as a string of text. If this is not defined, ivName must be defined.
 * @param config.keyName - (optional) The name of the vault property from which to retrieve the key.
 * @param config.ivName - (optional) The name of the vault property from which to retrieve the iv.
 * @param config.type - The type of encoding to use. This can be 'PLAIN', 'PLAIN_WITH_CRC', or 'TWISTED'.
 *
 * @return A string representing the decrypted object id.
 **/
module.exports.decrypt = function(data, config) {
    var key,
        iv,
        decipher,
        output,
        protectedKeys = nconf.get('vault:keys');

    data = '' + data;

    if (config.key) {
        key = getDesxKey(config.key);
    } else {
        key = getDesxKey((new Buffer(protectedKeys[config.keyName], 'base64')).toString('utf8'));
    }

    if (config.iv) {
        iv = getIV(config.iv);
    } else {
        iv = getIV((new Buffer(protectedKeys[config.ivName], 'base64')).toString('utf8'));
    }

    data = decode(data, config.type);

    decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    decipher.setAutoPadding(false);

    output = decipher.update(data);
    output = Buffer.concat([output, decipher.final()]);
    output = hexConverter.hexToDec(output.toString('hex'));

    return output;
};

function getDesxKey(keyStr) {
    var hash = crypto.createHash(HASH_ALGORITHM);
    hash.update(keyStr.slice(0, 16));
    var keyHash = hash.digest();

    var buf = keyHash.slice(0, 20);
    var desKey = buf.slice(0, 8);
    var pre = buf.slice(8, 16);
    var post = buf.slice(12, 20);
    var key = Buffer.concat([desKey, pre, post]);

    return key;
}

function getIV(ivStr) {
    var hash = crypto.createHash(HASH_ALGORITHM);
    hash.update(ivStr);
    var ivHash = hash.digest();
    var iv = ivHash.slice(0, 8);

    return iv;
}

function encode(data, type) {
    switch(type) {
    case 'TWISTED':
        return base32Twisted.encode(data);
    case 'PLAIN_WITH_CRC':
        data = crc16.addCrc(data);
        break;
    case 'PLAIN':
        break;
    default:
        break;
    }

    return base32.encode(data);
}

function decode(data, type) {
    var expectedLen = 8;
    var checkCRC = false;
    var decodedData;
    switch(type) {
    case 'TWISTED':
        return base32Twisted.decode(data);
        break;
    case 'PLAIN_WITH_CRC':
        expectedLen += 2;
        checkCRC = true;
        break;
    case 'PLAIN':
        break;
    default:
        break;
    }

    decodedData = base32.decode(data);

    if (decodedData.length !== expectedLen) {
        throw 'Decodes to ' + decodedData.length + ' bytes instead of ' + expectedLen + '.';
    }

    if (checkCRC && !crc16.hasValidCRC(decodedData)) {
        throw 'CRC check on "' + data + '" failed.';
    }

    decodedData = decodedData.slice(0, 8);
    return decodedData;
}
