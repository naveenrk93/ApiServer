'use strict';

var objutil = require('objutil'),
    constants = require('../constants'),
    calbuffer = require('../calbuffer'),
    calutils = require('../calutils'),
    threads = require('../threads'),
    nsutils = require('../nsutils'),
    threadCache = require('../thread-cache');

var EventEmitter = require('events').EventEmitter;

var defaultThreadId = threads.getDefaultThreadId();

function BaseActivity(type, name, status, data) {
    this._type = type || constants.UNSET;
    this._name = name || constants.UNSET;
    this._status = status || constants.Status.SUCCESS;
    this._data = (typeof data === 'string') ? data : (data || Object.create(null));
    this._klass = undefined;
    this._timestamp = Date.now();
    this._type = calutils.sanitize(this._type);
    this._name = calutils.sanitize(this._name);
    this._flushBuffer = false;
}


objutil.extend(BaseActivity, EventEmitter, {

    get messageClass() {
        return this._klass;
    },

    set messageClass(value) {
        this._klass = value;
    },


    get type() {
        return this._type;
    },

    set type(value) {
        this._type = calutils.sanitize(value);
    },


    get name() {
        return this._name;
    },

    set name(value) {
        this._name = calutils.sanitize(value);
    },


    get status() {
        return this._status;
    },

    set status(value) {
        this._status = String(value);
    },


    get timestamp() {
        return this._timestamp;
    },

    set timestamp(value) {
        this._timestamp = value;
    },

    get threadId() {
        this._threadId = this._threadId || threads.getThreadId() || defaultThreadId;
        return this._threadId;
    },

    set threadId(threadId) {
        this._threadId = threadId;
    },

    get eventId() {
        return this._eventId;
    },

    set eventId(value) {
        this._eventId = value;
    },

    get parent() {
        return this._parent;
    },

    set parent(value) {
        this._parent = value;
    },

    get parentEventId() {
        return this._parent && this._parent.eventId || 0;
    },

    get flushBuffer() {
        return this._flushBuffer;
    },

    set flushBuffer(value) {
        this._flushBuffer = value;
    },


    addData: function (key, value) {

        if (value !== undefined) {

            if (calutils.isPIISafe(key)) {
                // Both args are set, so just update data
                this._data[key] = calutils.filterPII(value);
            }

        } else {

            if (typeof key === 'object') {
                // Copy values to data
                Object.keys(key).forEach(function (prop) {
                    if (calutils.isPIISafe(prop)) {
                        this._data[prop] = calutils.filterPII(key[prop]);
                    }
                }.bind(this));
            } else {
                this._data.msg = this._data.msg || [];
                this._data.msg.push(calutils.filterPII(key));
            }
        }
        return this;
    },

    getContext: function () {
        return threadCache.get(this.threadId);
    },

    getCalBuffer: function () {
        var context = this.getContext();
        return calbuffer.getCalBuffer(this.threadId, context.isNestedCal, context.bufferFlushDelay);
    },

    complete: function (status) {

        if (status !== undefined) {
            this.status = status;
        }

        this._doComplete();

        var eventArgs = this._getEventArgs();
        var context = this.getContext();

        if (context.isBufferingEnabled && this.threadId !== defaultThreadId) {
            var buffer = this.getCalBuffer();
            var parentEventId = eventArgs.parentEventId || 0;

            buffer.push({instance: this, eventName: 'complete', args: eventArgs});
            if (this._flushBuffer && parentEventId === 0) {
                buffer.flushAll();
            }
        } else {
            this.emit('complete', eventArgs);
        }
        // restore to parent just in case the chain continue,
        // while it should never happen at runtime, only in unit tests
        if (this.parent) {
            nsutils.set(constants.TX, this.parent);
        }
    },


    _doComplete: function () {
        // noop
    },


    _getEventArgs: function () {
        var eventArgs, extraArgs;

        eventArgs = {
            type: this.type,
            name: this.name,
            status: this.status,
            data: this._data,
            messageClass: this._klass,
            timestamp: this.timestamp,
            threadId: this.threadId,
            eventId: this.eventId,
            parentEventId: this.parentEventId || 0
        };

        extraArgs = this._doGetEventArgs();
        if (extraArgs) {
            Object.getOwnPropertyNames(extraArgs).forEach(function (prop) {
                eventArgs[prop] = extraArgs[prop];
            });
        }
        return eventArgs;
    },


    _doGetEventArgs: function () {
        // noop
        return undefined;
    }

});

module.exports = BaseActivity;
