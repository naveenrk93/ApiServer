'use strict';

var querystring = require('querystring'),
    constants = require('../constants'),
    threads = require('../threads'),
    calutils = require('../calutils');

var MessageClass = constants.MessageClass;

function truncate(str, length) {
    // Truncate string to byte length to setup our guesstimation.
    var result = str.substring(0, length);

    // UTF-8 codepoint can't be longer than 4 bytes
    if (result.length * 4 < length) {
        return result;
    }

    var bytes = Buffer.byteLength(result),
        percent,
        guess,
        next,
        resultLen = 0,
        nextLen = 0;

    // Only proceed if original truncation wasn't enough.
    if (bytes > length) {
        // See how much bigger our truncated string is than the requested length.
        // (e.g. desired length is 80% of the string length)
        percent = length / bytes;

        // Calculate a guess as to the size of the resulting string.
        // This assumes a somewhat even distribution of single and multi-byte chars
        guess = Math.round(result.length * percent);

        // Grab our guess and cache the length
        result = result.substring(0, guess);
        resultLen = Buffer.byteLength(result);

        // Grab the next char and cache the length
        next = str.charAt(guess);
        nextLen = Buffer.byteLength(next);

        // If our estimate was too optimistic (e.g. the guess was smaller than
        // desired bytes - next character, append necessary chars until we reach
        // the requested length
        while (next && ((resultLen + nextLen) <= length)) {
            guess += 1;
            result += next;
            next = str.charAt(guess);
            nextLen = Buffer.byteLength(next);
            resultLen += nextLen;
        }

        // If the guess was too pessimistic, truncate char by char and work
        // backward until we get a valid length
        while (Buffer.byteLength(result) > length) {
            // Remove the trailing character and try again
            result = result.slice(0, -1);
        }
    }
    return result;
}

function noop(str) {
    return str;
}


function stringify(object) {
    return querystring.stringify(object, undefined, undefined, {
        encodeURIComponent: noop
    });
}


function stringifyData(data, delim) {
    if (typeof data === 'string') {
        return delim + calutils.escapeControlChars(data);
    }

    var res = '';
    var datares = '';

    var keys = Object.keys(data);
    var copied = 0;
    var copy = {};
    var subdelim = '';

    // Just a message and no other keys
    if (keys.length === 1 && data.msg && data.msg.length === 1) {
        return res + delim + calutils.escapeControlChars(data.msg.join());
    }

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = data[key];
        if (typeof value === 'object') {
            if (value instanceof Error) {
                res += delim + calutils.escapeControlChars(stringify(calutils.errorToJSON(value)));
                continue;
            }

            if (value && !Array.isArray(value)) {
                // serializing 1st level JSON object into String with '*' as delimiter
                var obj = calutils.escapeControlCharsAndAmp(calutils.stringifyObject(value));
                datares += subdelim + key + '=' + obj;
                subdelim = '&';
                continue;
            }
        }

        copied++;
        copy[key] = value;
    }

    // encode data and truncate to max allowed message length
    if (copied > 0) {
        if (typeof copy.stack === 'string') {
            // shorten long paths in Altus stack traces.
            copy.stack = copy.stack.replace(/\/x\/ebay\/cronus.+?\/scripts/ig, '');
        }

        datares += subdelim + calutils.escapeControlChars(stringify(copy));
    }

    return res + delim + datares;
}


function truncateField(field) {
    return truncate(String(field), constants.MAX_FIELD_LENGTH);
}


module.exports = {

    // Per: https://confluence.paypal.com/cnfl/display/CAL/CAL+APIs#CALAPIs-CalEvent
    // <Class>\t<Timestamp>\t<Type>\\t<Name>[\t<Status>][\t<Duration>][\t<Data>]
    format: function cal(args) {
        var res = '',
            delim = constants.FIELD_DELIMITER,
            defautlThreadId = threads.getDefaultThreadId(),
            threadId = args.threadId || defautlThreadId;

        if (args.messageClass === MessageClass.HEARTBEAT) {
            //Writing all the Heartbeat messages on Default Thread id.
            threadId = defautlThreadId;
        }

        res =
            truncateField(args.eventId || 0) + delim +
            truncateField(args.parentEventId || 0) + delim +
            truncateField(threadId) + delim +
            truncateField(args.messageClass +
                          calutils.formatTimestamp(args.timestamp)) +
            delim +
            truncateField(args.type) + delim +
            truncateField(args.name) + delim +
            truncateField(args.status);

        // Optional duration field
        if (args.duration !== undefined) {
            res += delim + truncateField(args.duration);
        }

        var data = args.data;

        if (data && args.messageClass !== MessageClass.TRANSACTION_START) {
            res += stringifyData(data, delim);
        }

        return truncate(res, constants.MAX_MESSAGE_LENGTH - constants.CRLF.length) + constants.CRLF;
    }

};
