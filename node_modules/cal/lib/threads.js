'use strict';

var calThreadIDPool = [],
    timeoutId,
    sortTimeoutId,
    threadIdReleaseInterval = 500, //500ms
    timerSortInterval = 60000,  // 1min
    timerResetInterval = 60000;  // 1min
var fakeCALThreadCounter = 2;
var constants = require('./constants');
var nsutils = require('./nsutils');
var threadCache = require('./thread-cache');
var calbuffer = require('./calbuffer');
var coreUtil = require('core-util-is');

var PM_ID = process.env.pm_id &&
            parseInt('0x' + 1000 * parseInt(process.env.pm_id, 10), 16);

function getDefaultThreadId() {
    //Writing all the Heartbeat messages on Default Thread id.
    var threadId = constants.DEFAULT_THREAD_ID;
    if (PM_ID) {
        threadId = PM_ID + threadId;
    }
    return threadId;
}

function resetThreadId() {
    //req threadId counter starts with 2, 1002, 2002...
    fakeCALThreadCounter = 1 + getDefaultThreadId();
}

resetThreadId();

var resetThreadIdPool = exports.resetThreadIdPool = function resetThreadIdPool() {
    calThreadIDPool = [];
    resetThreadId();
    timeoutId = null;
};

function compareNumbers(a, b) {
    return a - b;
}

//For better CAL view, sorting calThreadIDPool every timerSortInterval
function sortThreadIdPool() {
    calThreadIDPool.sort(compareNumbers);

    if (!timeoutId) {
        timeoutId = setTimeout(resetThreadIdPool, timerResetInterval);
        timeoutId.unref();
    }
}

//Sort threadId pool
function addThreadIdSortTimer() {
    sortTimeoutId = setInterval(sortThreadIdPool, timerSortInterval);
    sortTimeoutId.unref();
}

addThreadIdSortTimer();

exports.getDefaultThreadId = getDefaultThreadId;

exports.getNextThreadId = function getNextThreadId() {
    var threadId;

    if (calThreadIDPool.length > 0) {
        threadId = calThreadIDPool.shift();
    }

    if (!threadId) {
        threadId = fakeCALThreadCounter++;
    }

    if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
    }

    return threadId;
};

// Release thread Id for reuse after 150 ms gap
exports.releaseThreadId = function releaseThreadId(threadId) {
    var context = threadCache.get(threadId);
    var interval = Math.max(context.bufferFlushDelay, threadIdReleaseInterval);
    var releaseTimer;

    interval = coreUtil.isNumber(interval) ? interval : threadIdReleaseInterval;

    releaseTimer = setTimeout(function () {
        if (calThreadIDPool.indexOf(threadId) === -1) {
            calThreadIDPool.push(threadId);
        }
    }, interval);
    releaseTimer.unref();
};

exports.setThreadId = function setThreadId(threadId) {
    var context = threadCache.get(threadId);
    var oldThreadId = nsutils.getValue(constants.THREAD_ID);
    var isBufferingEnabled = context.isBufferingEnabled || false;
    if (oldThreadId && isBufferingEnabled) {
        calbuffer.move(oldThreadId, threadId, true);
    }
    nsutils.setValue(constants.THREAD_ID, threadId);
};

exports.getThreadId = function () {
    return nsutils.get(constants.THREAD_ID, getDefaultThreadId());
};
