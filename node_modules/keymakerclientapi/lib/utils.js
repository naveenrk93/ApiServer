// This module contains utilities that are used within KeyMakerClient module.

'use strict';
var path = require('path'),
    base64 = require('base64-paypal'),
    tryRequire = require('try-require'),
    deployEnv = require('environment-paypal'),
    derSequenceDecoder = require('./DerSeqDecoder'),
    fs = require('fs'),
    pem2jwk = require('pem-jwk').pem2jwk,
    cal = tryRequire('cal'),
    assert = require('assert'),
    equal = require('buffer-equal'),
    crypto = require('crypto');
    var topos = require('topos');
var AIV_CONSTANT = new Buffer('A65959A6', 'hex'); // Added from vault/keywrap requried to unwrap KEK with PIN
var defaultTimeOut, appName;
// These errors are agent errors that can occur at startup and we LOG when it occurs
var allowedErrors = ['AppDoesntExistError', 'MissingIdentityError'];
var protected_username,
    cryptoservPoolConfig,
    cryptoservProtocolName,
    appContext = '';
var nconf = require('nconf');
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(':');
    return [d.getYear() % 100, d.getMonth() + 1, d.getDate()].join('-') + ':' + time;
}

function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

function getAppName() {
    if (!appName) {
        var pkg, pkgFile;
        pkgFile = path.join(process.cwd(), 'package.json');
        pkg = tryRequire(pkgFile);
        appName = pkg && pkg.name;
    }
    return appName;
}

function getWeekStart(date) {
    var today = date || new Date();
    var day = today.getDay() + 1;
    date = today.getDate() - day;
    return new Date(today.setDate(date + 1));
}

function getSessionKeyName(date) {
    var endDate = getWeekStart(date);
    var endYear = String(endDate.getFullYear());
    var endMonth = ('0' + (endDate.getMonth() + 1)).slice(-2);
    var startDay = ('0' + endDate.getDate()).slice(-2);
    return endYear + endMonth + startDay;
}

function getNetStringLength(str) {
    if (!str || typeof str != 'string') return 0;
    return Number(str.substring(0, str.indexOf(':')));
}

function formatVersion(str) {
    if (!str) return '';
    else {
        str = String(str);
        return ('0000' + str).substring(str.length);
    }
}

function validateInput(obj, operation) {
    try {
        if (!obj) throw new Error('Invalid input: params object is mandatory input, check api usage');
        if (!obj.keyId) {
            if (!obj.cryptKeyId || !obj.macKeyId) throw new Error('Invalid input: keyId is mandatory in params, check api usage');
        }
        if (!obj.data) {
            if (operation === 'secretprovider' || operation === 'verify') return null;
            else throw new Error('Invalid input: expected data in params object, check api usage');
        }
        return null;
    } catch (e) {
        return e;
    }
}

function checkEmptyResponse(res) {
    if (!res) throw new Error('Unexpected LocalCryptoOutputEmptyError');
}

function getResponseObj(encData, opName, cryptKeyId, macKeyId, version) {
    var res = {};
    res.response_code = 200;
    res.server_info = 'LocalCrypto:' + opName;
    res.result = {};
    if (opName == 'seal' || opName == 'unseal') {
        (cryptKeyId != undefined) ? res.result.cryptKeyId = cryptKeyId: res.result.cryptKeyId = null;
        (macKeyId != undefined) ? res.result.macKeyId = macKeyId: res.result.macKeyId = null;
    } else {
        (cryptKeyId != undefined) ? res.result.keyId = cryptKeyId: res.result.keyId = null;
    }
    res.result.encodedData = encData;
    res.result.version = version;
    res.result.error;
    return res;
}

function createSubKey(keyName) {
    if (keyName) {
        keyName = keyName.trim();
        if (keyName.indexOf('encrypted_') === 0) {
            return keyName.substring(10).replace(/_[0-9]+$/g, '');
        } else {
            return keyName.replace(/_[0-9]+$/g, '');
        }
    } else {
        throw new Error('Invalid Input: keyName is mandatory to create a subkey');
    }
}

function writeCalEvent(operationName, keyName, msg, status) {
    var calEvent;
    status = status || 'SUCCESS';
    if (cal) {
        calEvent = cal.createEvent(operationName, keyName);
        calEvent.status = cal.Status[status];
        if (msg) {
            calEvent.addData(msg);
        }
        calEvent.complete();
    } else {
        console.error(timestamp(), operationName, keyName, status, msg || '');
    }
}

function createCalTransaction(transactionType, data) {
    if (cal) {
        var calTxn = cal.createTransaction(transactionType, data);
        var correlationId = getCorrelationId();
        if (correlationId) calTxn.correlationId = correlationId;
        calTxn.status = getCalStatus();
        return calTxn;
    } else {
        console.error(timestamp(), transactionType, data, 'REASON FOR CONSOLE ERRLOG: CAL MODULE REQUIRE FAILED');
        return null;
    }
}

function getCorrelationId() {
    if (cal) return cal.correlationId;
    else return '';
}

function getCalStatus(str) {
    if (str && str === 'success') return cal.Status.SUCCESS;
    else return cal.Status.ERROR;
}

function getTimeOut() {
    if (defaultTimeOut) return defaultTimeOut;
    if (deployEnv.isDev()) return 2000;
    else return 500;
}

function setTimeOut(timeOut) {
    defaultTimeOut = timeOut;
    return defaultTimeOut;
}

function getDefaultHost() {
    if (deployEnv.isDev()) return 'keymakeragentpool-vip.ccg21.dev.paypalcorp.com';
    else return '127.0.0.1';
}

function getKeyMakerAPIhostport() {
    var conf = (nconf && nconf.get('keymakerclientapi')) || (topos.init(nconf.get('topos'), nconf) && nconf.get('keymakerclientapi'));
    var port = conf && conf.keymakerapi && conf.keymakerapi.port || '14758';
    var host;
    if (deployEnv.isDev())
        host = 'keymakerapi-vip.qa.paypal.com';
    else
        host = conf.keymakerapi.host;
    return {
        'host': host,
        'port': port
    };
}

function isAllowedError(completeStr) {
    completeStr = completeStr || '';
    for (var i = 0; i < allowedErrors.length; i++) {
        var n = completeStr.indexOf(allowedErrors[i]);
        if (n > 0) return true;
        else continue;
    }
    return false;
}

function derToJwk(privKeyDer) {
    if (privKeyDer instanceof Buffer) {
        privKeyDer = privKeyDer.toString('base64');
    }
    var privKey = extractPrivKeyFromDerSeq(privKeyDer);
    var privKeyPEM = convertToPEMFormat(privKey);
    var privKeyJWK = pem2jwk(privKeyPEM.toString('ascii'));

    return privKeyJWK;
}

function convertToPEMFormat(cert, isFirst) {
    var beginGuardStr, endGuardStr;
    try {
        if (!cert) throw new Error('No Cert Passed to convert');
        // isFirst will be send only for lists and lists would be only certs or CAs.
        // isFirst wont be defined for non-lists and privateKeys are not Lists.
        if (isFirst === undefined) {
            beginGuardStr = '-----BEGIN RSA PRIVATE KEY-----\n';
            endGuardStr = '\n-----END RSA PRIVATE KEY-----';
        } else {
            // The following two strings are the PEM format guards for CERTS
            beginGuardStr = (isFirst === 0) ? '-----BEGIN CERTIFICATE-----\n' : '\n-----BEGIN CERTIFICATE-----\n';
            endGuardStr = '\n-----END CERTIFICATE-----';
        }

        //Get the base64 encoded value of the buffer data read from disk
        var certStr = base64.encode(cert).toString(),
              pemFormatCert = '',
              index = 0;
        // Let's put the string in PEM format
        while(index + 72 < certStr.length) {
            pemFormatCert += certStr.slice(index, index + 72);
            pemFormatCert += '\n';
            index += 72;
        }
        if (index < certStr.length) pemFormatCert += certStr.slice(index);

        // add the pem guards to the final formatted cert
        pemFormatCert = beginGuardStr + pemFormatCert + endGuardStr;
        return new Buffer(pemFormatCert);
    } catch (e) {
        console.error('KeyMakerClient-convertToPEMFormat-CaughtError-', e);
    }
}

function getDefaultExternalSSLConfigResponseObj(cacheType) {
    if (!cacheType) cacheType = 'LocalKeyMakerCache';
    var externalSSLConfig = {};
    externalSSLConfig.response_code = 200;
    externalSSLConfig.server_info = cacheType;
    externalSSLConfig.result = {};
    return externalSSLConfig;
}

// This function expects the input to be base64encoded DER data from the agent
// returns buffer of private Key
function extractPrivKeyFromDerSeq(derStr) {
    if (!derStr) throw new Error('base64 encoded DER data is mandatory');
    var src = {}, ans = {}, ans1_d, hexStr;
    src.value = derStr;
    // The Decoder is capable of detecting the type of input
    // data but we enforce it to expect only b64 encoded data
    // to ensure we retain focus of the usecase.
    derSequenceDecoder.convert(src, ans, 'decode_B64');
    if(!ans.hasOwnProperty('value')) throw new Error('asn1 decoder could not process b64enc DER and returned empty value');
    // value is present in the ans object.
    ans1_d = ans.value;

    // The Last value of the ans output is expected to be a } followed by a new line
    if (ans1_d.slice(-2) !== '}\n') throw new Error('Unexpected response from asn1 decoder');
    else {
        // 12 is the size of the string 'OCTETSTRING + space'
        // ::ToDO:: add comment for 3 and verify
        hexStr = ans1_d.slice(ans1_d.indexOf('OCTETSTRING') + 12, -3);
        return new Buffer(hexStr, 'hex');
    }
}

function checkLocalKeyCacheExists(keyCachePath, callback) {
    fs.readFile(keyCachePath, 'UTF-8', function (err) {
        if(err)
            return callback(false);
        return callback(true);
    });
}

function getProtectedPath(opt) {
    var keyCachePath;
    if( (!opt.env && !opt.name) || opt.env === "DEVELOPMENT") { // Dev
        keyCachePath = opt.dir || path.dirname(require.resolve('testkeystore/package.json'));
    } else { // Stage, Sandbox, Live
        keyCachePath = path.join(process.cwd(), 'keystore_nodeweb');
    }

    return keyCachePath;
}

function getKEK(appname) {
    var pin;
    (process.env[appname.toUpperCase() + '_PIN']) ? pin = process.env[appname.toUpperCase() + '_PIN'] : pin = process.env['NODEWEB_PIN'];
    return pin;
}

function logTimestamp(keyCachePath) {
    fs.stat(keyCachePath, function (err, stats) {
        if(!err) {
            console.log('Local key cache last refreshed on: ', new Date(stats.mtime));
            writeCalEvent('create', 'km_init_step2', 'Local key cache last refreshed on: ' + new Date(stats.mtime));
        }
    });
}

// functions unwrap, base64Decode, keywrapUnwrap, arraycopy, createDecipher, getComponents, and validAIV have been replicated from vault/keywrap
function unwrap(ciphertext, kek) {
    assert(Buffer.isBuffer(ciphertext), 'ciphertext must be a Buffer');
    assert(Buffer.isBuffer(kek), 'kek must be a Buffer');

    var inlen, components, key, plaintext;
    var algorithm, decipher;
    inlen = ciphertext.length;

    // ciphertext must be n>=2 64-bit (16B) blocks
    if (inlen % 8 || inlen < 16) {
        return undefined;
    }

    if (inlen === 16) {

        // decrypt as single AES block (ECB) with kek
        algorithm = 'aes-' + kek.length * 8 + '-ecb';
        decipher = crypto.createDecipheriv(algorithm, kek, '');
        decipher.setAutoPadding(false);
        plaintext = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    } else {
        // RFC3394(ciphertext, kek)
        plaintext = keywrapUnwrap(ciphertext, kek);
    }

    components = getComponents(plaintext);

    if (!(validAIV(components))) {
        return undefined;
    }

    key = components.paddedKey.slice(0, components.mli);
    return key;
}

function base64Decode(value) {
    value = value.replace(/\-/g, '+');
    value = value.replace(/\./g, '/');

    if (!~value.indexOf('=')) {
        value = rightPad(value, '=', value.length + (value % 4));
    }

    return new Buffer(value, 'base64');
}

function rightPad(str, chr, size) {
    while (str < size) {
        str += chr;
    }
    return str;
}

function keywrapUnwrap(input, kek, iv) {
    var inLength, ivLength, block, a, buffer, cipher, ciphertext;
    var t, k, j, i;

    assert(input, 'Input is null or not defined');
    assert(kek, 'kek is null or not defined');
    //assert(iv, 'iv is null or not defined');

    inLength = input.length;
    ivLength = 8;

    var n = inLength / 8;
    if ((n * 8) !== inLength) {
        return null;
    }

    block = new Buffer(inLength - ivLength);
    a = new Buffer(ivLength);
    buffer = new Buffer(8 + ivLength);

    arraycopy(input, 0, a, 0, ivLength);
    arraycopy(input, ivLength, block, 0, inLength - ivLength);

    n -= 1;

    for (j = 5; j >= 0; j--) {
        for (i = n; i >= 1; i--) {
            arraycopy(a, 0, buffer, 0, ivLength);
            arraycopy(block, 8 * (i - 1), buffer, ivLength, 8);

            t = n * j + i;
            for (k = 1; t !== 0; k++) {
                buffer[ivLength - k] ^= t;
                t >>>= 8;
                //	t = 0;
            }

            cipher = createDecipher(kek);
            ciphertext = cipher.update(buffer);
            buffer = Buffer.concat([ ciphertext, cipher.final() ]);

            arraycopy(buffer, 0, a, 0, 8);
            arraycopy(buffer, 8, block, 8 * (i - 1), 8);
        }
    }

    if (iv) {
        if (a.toString('hex') !== iv.toString('hex')) {
            return null;
        }
        return block;
    }

    var ivAndBlock = new Buffer(8 + block.length);
    arraycopy(a, 0, ivAndBlock, 0, 8);
    arraycopy(block, 0, ivAndBlock, 8, block.length);
    return ivAndBlock;
}

function arraycopy(src, srcPos, dest, destPos, length) {
    // Plz don't pass nulls
    srcPos = isNaN(srcPos) ? 0 : srcPos;
    destPos = isNaN(destPos) ? 0 : destPos;
    length = isNaN(length) ? src.length : length;
    src.copy(dest, destPos, srcPos, srcPos + length);
}

function createDecipher(key) {
    assert(Buffer.isBuffer(key), 'key must be a Buffer instance');
    var decipher = crypto.createDecipheriv('aes-' + (key.length * 8) + '-ecb', key, '');
    decipher.setAutoPadding(false);
    return decipher;
}

function getComponents(plaintext) {
    var aiv, paddedKey, constant, mli;

    aiv = plaintext.slice(0, 8); // first 64B
    paddedKey = plaintext.slice(8);
    constant = aiv.slice(0,4); // MSB(32, aiv)
    mli = aiv.readUInt32BE(4); // LSB(32, aiv) (Big-Endian)

    return {
        aiv: aiv,
        paddedKey: paddedKey,
        constant: constant,
        mli: mli
    };
}

function validAIV(components) {
    var n, b, padding, empty;

    // Step 1: validate constant
    if (!equal(components.constant, AIV_CONSTANT)) {
        return false;
    }

    // Step 2: validate MLI
    n = components.paddedKey.length / 8;
    if ((components.mli <= 8 * (n-1)) || (components.mli > 8 * n)) {
        return false;
    }

    // Step 3: check padding
    b = (8 * n) - components.mli;
    padding = components.paddedKey.slice(components.mli, components.mli + b);

    empty = new Buffer(b);
    empty.fill(0);
    if (!equal(padding, empty)) {
        return false;
    }

    return true;
}

function setProtectedUserName(username) {
    protected_username = username;
}

function getProtectedUserName() {
    return protected_username;
}

function setCsPoolConfig(options) {
    cryptoservPoolConfig = options;
}

function getCsPoolConfig() {
    return cryptoservPoolConfig;
}

function validatePkg(pkg) {
    var pkgValidation = {};
    pkgValidation.isValid = false;
    pkgValidation.error = new Error('Package validation failed');

    if(!pkg || pkg === null) {
        pkgValidation.error = new Error('package returned by vault is null');
    } else if (!pkg.getClientCredentials()) {
        pkgValidation.error = new Error('protected package does not contain client credentials');
    } else if (!pkg.get('encrypted_keymaker_agent_passphrase')) {
        pkgValidation.error = new Error('');
    } else if (!pkg.get('client_sessions')) {
        pkgValidation.error = new Error('');
    } else {
        pkgValidation.isValid = true;
        pkgValidation.error = null;
    }

    return pkgValidation;
}

function getAppContextName(servername) {
    return getAppName() + "_" + servername + "_app_context";
}

function getCryptoservhostport() {
    var csConf = (nconf && nconf.get('keymakerclientapi')) || (topos.init(nconf.get('topos'), nconf) && nconf.get('keymakerclientapi'));
    return csConf;
}

function getCryptoservProtocol() {
    if (cryptoservProtocolName) return cryptoservProtocolName;
    return 'cryptoserv 2';
}

function setCryptoservProtocol(protocol) {
    cryptoservProtocolName = protocol;
}

function getAppContext() {
    return appContext;
}

function setAppContext(ac) {
    appContext = ac;
}

module.exports = {
    getAppName: getAppName,  
    timestamp: timestamp,
    getNetStringLength: getNetStringLength,
    getSessionKeyName: getSessionKeyName,
    createSubKey: createSubKey,
    getResponseObj: getResponseObj,
    formatVersion: formatVersion,
    validateInput: validateInput,
    checkEmptyResponse: checkEmptyResponse,
    writeCalEvent: writeCalEvent,
    createCalTransaction: createCalTransaction,
    getCorrelationId: getCorrelationId,
    getCalStatus: getCalStatus,
    getTimeOut: getTimeOut,
    setTimeOut: setTimeOut,
    getDefaultHost: getDefaultHost,
    isAllowedError: isAllowedError,
    convertToPEMFormat: convertToPEMFormat,
    extractPrivKeyFromDerSeq: extractPrivKeyFromDerSeq,
    getDefaultExternalSSLConfigResponseObj: getDefaultExternalSSLConfigResponseObj,
    derToJwk: derToJwk,
    checkLocalKeyCacheExists: checkLocalKeyCacheExists,
    getProtectedPath: getProtectedPath,
    getKEK: getKEK,
    logTimestamp: logTimestamp,
    unwrap: unwrap,
    base64Decode: base64Decode,
    setProtectedUserName: setProtectedUserName,
    getProtectedUserName: getProtectedUserName,
    setCsPoolConfig: setCsPoolConfig,
    getCsPoolConfig: getCsPoolConfig,
    validatePkg: validatePkg,
    getAppContextName: getAppContextName,
    getKeyMakerAPIhostport: getKeyMakerAPIhostport,
    getCryptoservhostport: getCryptoservhostport,
    getCryptoservProtocol: getCryptoservProtocol,
    setCryptoservProtocol: setCryptoservProtocol,
    getAppContext: getAppContext,
    setAppContext: setAppContext
};
