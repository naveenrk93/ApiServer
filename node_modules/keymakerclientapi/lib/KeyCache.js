'use strict';
var debug = require('debuglog')('kmsclientdebug'),
    Dict = require('collections/dict'),
    assert = require('assert'),
    utils = require('./utils');

// symmetric and secret key structs
var vaultBinaryProps = new Dict(),
    vaultStringProps = new Dict(),
    keyMakerBinaryProps = new Dict(),
    keyMakerStringProps = new Dict();

// asymmetric or keystore structs
var keyMakerKeyStoreProps = new Dict(),
    vaultKeyStoreProps = new Dict(),
    consolidatedTrustStoreProps = new Dict(),
    ssoKeyStoreKeyMakerProps = new Dict();

var keymakerapiCert;
var revokedJTIList = [];

function getGCMKeyFromCache(keyId) {
    var gcmStore = {};
    // setting two attributes of gcmStore to undefined
    gcmStore.key;
    gcmStore.version;

    var gcmVersion = getAlgoFromCache(utils.createSubKey(keyId) + '_version');
    var gcmKeyId = keyId + '_' + utils.formatVersion(gcmVersion.algo);
    gcmStore.key = keyMakerBinaryProps.get(gcmKeyId);
    // gcmVersion.algo here refers to the version of the key;
    // the version is maintained in the keymaker algoCache hence the name
    if (gcmVersion.algo) gcmStore.version = parseInt(gcmVersion.algo);
    return gcmStore;
}

function getKeyFromCache(keyId) {
    assert.ok(keyId, 'keyCache-getKeyFromCache: keyId cannot be null');
    var key, store = {};
    store.key;
    store.cache = 'KeyNotFoundInCache';
    key = keyMakerBinaryProps.get(keyId);
    if (key) {
        debug('Key Found in keymaker cache');
        store.key = key;
        store.cache = 'keymaker';
        return store;
    } else {
        if (/_crypt_key/.test(keyId)) {
            var gcmStore = getGCMKeyFromCache(keyId);
            if (gcmStore.key) {
                debug('GCM Key Found in keymaker cache');
                store.key = gcmStore.key;
                store.cache = 'keymaker';
                // version property is set to undefined regardless of it's value
                // if version not found, we simply intend to return undefined
                store.version;
                if (gcmStore.version) {
                    debug('GCM Key Version Found in keymaker cache');
                    store.version = gcmStore.version;
                }
                return store;
            }
        }
    }
    key = vaultBinaryProps.get(keyId);
    if (key) {
        debug('Key Found in Vault Cache');
        store.key = key;
        store.cache = 'vault';
        return store;
    }
    var asymKeyId = keyId + '_asymmetric_key';
    if (keyMakerBinaryProps.has(asymKeyId)) {
        store.cache = 'nosupport';
        return store;
    }
    debug('KeyName:' + keyId + ' Not Found in Cache');
    return store;
}

function getAlgoFromCache(algoKey) {
    assert.ok(algoKey, 'keyCache-getAlgoFromCache: algoKey cannot be null');
    var algo, store = {};
    store.algo;
    store.cache = 'AlgoNotFoundInCache';
    algo = keyMakerStringProps.get(algoKey);
    if (algo) {
        debug('AlgoName Found in keymaker cache');
        store.algo = algo;
        store.cache = 'keymaker';
        return store;
    }
    algo = vaultStringProps.get(algoKey);
    if (algo) {
        debug('AlgoName Found in Vault Cache');
        store.algo = algo;
        store.cache = 'vault';
        return store;
    }
    debug('AlgoName:' + algoKey + ' Not Found in Cache');
    return store;
}

function getTypeFromCache(keyName) {
    assert.ok(keyName, 'keyCache-getTypeFromCache: keyName cannot be null');
    var type, store = {};
    store.type;
    store.cache = 'TypeNotFoundInCache';
    var name = utils.createSubKey(keyName) + '_type';
    type = keyMakerStringProps.get(name);
    if (type) {
        debug('Type found in keymaker cache');
        store.type = type;
        store.cache = 'keymaker';
        return store;
    }
    if (!keyName.includes('crypt_key') && !keyName.includes('mac_key')) {
        var passphrase = vaultBinaryProps.get(keyName);
        if (passphrase) {
            debug('Key found in Vault Cache');
            store.type = 'nonkey';
            store.cache = 'vault';
            return store;
        }
    }
    debug('Type for:' + keyName + ' Not Found in Cache');
    return store;
}

function getVersionFromCache(versionKey) {
    assert.ok(versionKey, 'keyCache-getVersionFromCache: key cannot be null');
    var version, store = {};
    store.version;
    store.cache = 'VersionNotFoundInCache';
    version = keyMakerStringProps.get(versionKey);
    if (version) {
        debug('Version found in keymaker cache');
        store.version = version;
        store.cache = 'keymaker';
        return store;
    }
    debug('Version for:' + versionKey + ' not Found in Cache');
    return store;
}

function getKMKeyStoreCache(keyStoreName) {
    assert.ok(keyStoreName, 'keyCache-getKeyMakerKeyStoreCache: keyStoreName cannot be null');

    var computedKeyStoreName = keyStoreName;

    if (!/_keymaker$/i.test(keyStoreName)) {
        computedKeyStoreName = computedKeyStoreName + '_keymaker.nks';
    } else {
        computedKeyStoreName = computedKeyStoreName + '.nks';
    }
    return keyMakerKeyStoreProps.get(computedKeyStoreName);
}

function getLocalKeyMakerSSOKeyStore(keyStoreName) {
    var calTxn = utils.createCalTransaction('protected_ssoconfig', keyStoreName);
    try{
        assert.ok(keyStoreName, 'In keyCache: keyStoreName cannot be null');
        if (!/_keymaker$/i.test(keyStoreName)) {
            keyStoreName = keyStoreName + '_keymaker.nks';
        } else {
            keyStoreName = keyStoreName + '.nks';
        }
        var ssoConfig = ssoKeyStoreKeyMakerProps.get(keyStoreName);
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        return ssoConfig;
    } catch (e) {
        throw new Error('In getLocalKeyMakerSSOKeyStore-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function processAgentSSOKeyStore(ssoAgentKeyStore) {
    try {
        if (Object.keys(ssoAgentKeyStore).length === 0) throw new Error('Agent Response is empty; cannot process null response');
        if (!ssoAgentKeyStore.hasOwnProperty('result')) throw new Error('Agent Response does not contain result property');
        if (!ssoAgentKeyStore.hasOwnProperty('response_code')) throw new Error('Agent Response does not contain response code');
        if (!ssoAgentKeyStore.hasOwnProperty('server_info')) throw new Error('Agent Response does not contain server_info');

        var ssoConfig = utils.getDefaultExternalSSLConfigResponseObj();
        ssoConfig.response_code = ssoAgentKeyStore.response_code;
        ssoConfig.server_info = ssoAgentKeyStore.server_info;

        processKeyMakerSSOKeyStore(ssoAgentKeyStore.result, ssoConfig);
        return ssoConfig;
    } catch (e) {
        debug('In processAgentSSOKeyStore-' + e);
        return null;
    }
}

function processKeyMakerSSOKeyStore(ssoKMKeyStore, ssoKeyStoreConfig) {
    try {
        if (Object.keys(ssoKMKeyStore).length === 0) throw new Error('keystore object cannot be empty');
        if (Object.keys(ssoKeyStoreConfig).length === 0) throw new Error('Default response object cannot be empty');

        // Processing client privateKey
        if (!ssoKMKeyStore.hasOwnProperty('privateKey')) throw new Error('\'privateKey\' property not found');
        var pkcs_priv_der = ssoKMKeyStore.privateKey;
        // some validation
        if (!pkcs_priv_der) throw new Error('privateKey in SSO use-case cannot be null');
        if (pkcs_priv_der.constructor === Array) throw new Error('privateKey cannot be a list, should be single');

        // We need to ensure pkcs_priv_der is not a Buffer and it base64 encoded 
        // else the DerSeqDecoder will complain.
        if (pkcs_priv_der instanceof Buffer) {
            pkcs_priv_der = pkcs_priv_der.toString('base64');
        }
        var privateKey = utils.extractPrivKeyFromDerSeq(pkcs_priv_der);
        var formattedKey = utils.convertToPEMFormat(privateKey);
        // set the formatted privateKey which is in PEM format
        ssoKeyStoreConfig.result.clientPrivateKey = formattedKey.toString();

        // Processing client publicCert
        if (!ssoKMKeyStore.hasOwnProperty('publicCerts')) throw new Error('\'publicCerts\' property not found');
        var publicCertsList_NonPEM = ssoKMKeyStore.publicCerts;
        if (!publicCertsList_NonPEM ||  Object.keys(publicCertsList_NonPEM).length === 0) {
            throw new Error('publicCerts in SSO use-case cannot be null');
        }
        if (Object.keys(publicCertsList_NonPEM).length > 1) {
            // We are not expecting a list of publicCerts in our PP specific internal SSO use-case.
            // At any time we decide to, the rest of the logic would remain the same and we just
            // would remove this if block alone.
            throw new Error('publicCerts in SSO use-case cannot be an Array');
        }
        var publicCertsList_PEM = [];
        // We are still handling publicCerts as a List though we expect only one entry because of the nature of
        // keystore implementation in Agent and keymakerapi serv.
        for (var i = 0; i < publicCertsList_NonPEM.length; i++) {
            var formattedCert = utils.convertToPEMFormat(new Buffer(publicCertsList_NonPEM[i], 'base64'), i);
            publicCertsList_PEM.push(formattedCert);
        }
        // set publicCert - Taking only the first element because we don't expect it to have a list of certs
        if (publicCertsList_PEM.length > 0) ssoKeyStoreConfig.result.clientPublicCert = publicCertsList_PEM[0].toString();

        // Processing SSO server cert
        var trustedCertsList_NonPEM = ssoKMKeyStore.trustedCerts;

        if (!trustedCertsList_NonPEM ||  Object.keys(trustedCertsList_NonPEM).length === 0) {
            throw new Error('trustedCert in SSO use-case cannot be empty');
        }

        if (Object.keys(trustedCertsList_NonPEM).length > 1) {
            // We are not expecting a list of trustedCerts in our PP specific internal SSO use-case.
            // At any time we decide to, the rest of the logic would remain the same and we just
            // would remove this if block alone.
            throw new Error('trustedCert in SSO use-case cannot be an Array');
        }
        var certStr;
        // We are still handling trustedCerts as a List though we expect only one entry because of the nature of
        // keystore implementation in Agent and keymakerapi serv.
        for (var j = 0; j < trustedCertsList_NonPEM.length; j++) {
            // No conversion required for SSO as the sso-paypal module needs it as a cert String
            certStr = trustedCertsList_NonPEM[j];
        }
        // set trustedCerts - Taking only the first element because we don't expect it to have a list of trustedCerts
        ssoKeyStoreConfig.result.trustedCert = certStr.toString('base64');
    } catch(e){
        throw new Error('processKeyMakerSSOKeyStore:' + e);
    }
}

// This method is basically to deep copy the contents of
// vaultKeyStore dict to the consolidatedKeyStore Dict
// To be called only after vaultKeyStore is populated completely.
function vaultKeyStoreDone() {
    // ::ToDo:: Assertions to be added
    if (vaultKeyStoreProps.has('passphrase')) {
        consolidatedTrustStoreProps.set('passphrase', vaultKeyStoreProps.get('passphrase'));
    }
    if (vaultKeyStoreProps.has('trustedServers')) {
        var trustedServersList = [];
        trustedServersList.push(vaultKeyStoreProps.get('trustedServers'));
        consolidatedTrustStoreProps.set('trustedCerts', trustedServersList);
    }
    if (vaultKeyStoreProps.has('certs')) {
        consolidatedTrustStoreProps.set('cert', vaultKeyStoreProps.get('certs'));
    }
    if(vaultKeyStoreProps.has('key')) {
        consolidatedTrustStoreProps.set('key', vaultKeyStoreProps.get('key'));
    }
}

function snapOfCache() {
    var snap;
    snap = 'vaultKeys: {' + vaultBinaryProps.keys() + 
           '} vaultAlgos: {' + vaultStringProps.keys() + 
           '} vaultKeyStore: {' + vaultKeyStoreProps.keys() + 
           '} keyMakerKeys: {' + keyMakerBinaryProps.keys() + 
           '} keyMakerAlgos: {' + keyMakerStringProps.keys() + 
           '} keyMakerKeyStore: {' + keyMakerKeyStoreProps.keys() + 
           '} ConsolidatedKeyStore: {' + consolidatedTrustStoreProps.keys() + 
           '} ssoKeyMakerKeyStore: {' + ssoKeyStoreKeyMakerProps.keys() + '}';
    return snap;
}

function viewCache() {
    // This function has only debug statements meant purely for testing purpose
    // Nobody ever wants to look at the cache
    debug('vault_keyCache properties are :');
    debug(vaultBinaryProps.entries());
    debug('vault_algoCache properties are');
    debug(vaultStringProps.entries());
    debug('vault KeyStore Properties are ');
    debug(vaultKeyStoreProps.entries());
    debug('keyMaker_keyCache properties are ');
    debug(keyMakerBinaryProps.entries());
    debug('KeyMaker_algoCache properties are ');
    debug(keyMakerStringProps.entries());
    debug('keyMaker KeyStore Properties are ');
    debug(keyMakerKeyStoreProps.entries());
    debug('Consolidated KeyStore Properties are ');
    debug(consolidatedTrustStoreProps.entries());
    debug('KeyMaker_ssoKeyStore properties are ');
    debug(ssoKeyStoreKeyMakerProps.entries());
}
module.exports = {
    getKeyFromCache: getKeyFromCache,
    getAlgoFromCache: getAlgoFromCache,
    getKMKeyStoreCache: getKMKeyStoreCache,
    getVersionFromCache: getVersionFromCache,
    vaultKeyCache: vaultBinaryProps,
    vaultAlgoCache: vaultStringProps,
    kmKeyCache: keyMakerBinaryProps,
    kmalgoCache: keyMakerStringProps,
    keyMakerKeyStoreProps: keyMakerKeyStoreProps,
    vaultKeyStoreRegistry: vaultKeyStoreProps,
    vaultKeyStorePopulated: vaultKeyStoreDone,
    consolidatedTrustStoreRegistry: consolidatedTrustStoreProps,
    ssoKeyStoreKeyMakerProps: ssoKeyStoreKeyMakerProps,
    getLocalKeyMakerSSOKeyStore: getLocalKeyMakerSSOKeyStore,
    processAgentSSOKeyStore: processAgentSSOKeyStore,
    processKeyMakerSSOKeyStore: processKeyMakerSSOKeyStore,
    snapOfCache: snapOfCache,
    debugCache: viewCache,
    keymakerapiCert: keymakerapiCert,
    revokedJTIList: revokedJTIList,
    getTypeFromCache: getTypeFromCache
};