var async = require('async'),
    tls = require('tls'),
    debug = require('debuglog')('kmsclientdebug'),
    deployEnv = require('environment-paypal'),
    utils = require('./utils'),
    NetString = require('netstring-stream'),
    keyCache = require('./KeyCache'),
    ppcryptutils = require('cryptutils-paypal'),
    tlsCredentials;

// Below are the constants used by Cryptosev as Command for the operation
// The commands are declared as constant variable
// The error commands that cryptoserv would reply with are stored in map for better lookup

// Cryptoserv Command constants
var COMMAND_ZERO = 0,                                   // Used for Nested Netstring
CRYPTOSERV_PROTOCOL_COMMAND = 2002,                 // Handshake Commands
CLIENT_USERNAME_COMMAND = 2003,
RANDOM_CHALLENGE_COMMAND = 1001,
CHALLENGE_RESPONSE_COMMAND = 2004,
CRYPTOSERV_CONNECTION_ACCEPTED = 1002,
CLIENT_APP_CTX_COMMAND = 2009;

// Cryptoserv response error commands
var ERROR_MAP = {
6: 'CRYPTOSERV_SERVER_ERROR',
10: 'CRYPTOSERV_INVALID_COMMAND',
22: 'CRYPTOSERV_UNAUTHORIZED_APP_CTX',               // Application Context errors
23: 'CRYPTOSERV_EXPIRED_APP_CTX',                    // Application Context errors
24: 'CRYPTOSERV_REVOKED_APP_CTX',                    // Application Context errors
25: 'CRYPTOSERV_NO_APP_CTX',                         // Application Context errors
26: 'CRYPTOSERV_MALFORMED_APP_CTX',                  // Application Context errors
1003: 'CRYPTOSERV_CONNECTION_REJECTED_PROTOCOL',     // Handshake errors
1004: 'CRYPTOSERV_CONNECTION_REJECTED_UNKNOWN_USER',
1005: 'CRYPTOSERV_CONNECTION_REJECTED_FAILED_AUTH',
1006: 'SERVER_UNEXPECTED_COMMAND',                   // General errors
1007: 'SERVER_INTERNAL_ERROR'
};

// Cryptoserv data constants
var CRYPTOSERV_PROTOCOL_NAME = utils.getCryptoservProtocol(),
CHALLENGE_ENCRYPTION_KEY = 'encrypted_auth_key';

// Construct configuration for KeyMaker Agent
function constructAgentConfig(options) {
    var config = {};
    config.poolName = 'KmAgent_Pool';
    config.host = options.host ? options.host : utils.getDefaultHost();
    config.port = options.port ? options.port : 23456;
    config.min = options.agentMinConn ? options.agentMinConn : 1;
    config.max = options.agentMaxConn ? options.agentMaxConn : 20;
    config.isPoolLogEnabled = options.enablePoolLog ? options.enablePoolLog : false;
    config.reapIntervalMillis = options.freqToCheckIdle ? options.freqToCheckIdle : 5000;
    config.idleTimeoutMillis = options.idleTimeOut ? options.idleTimeOut : 600000;
    config.credentials = options.credentials || {};
    config.sessions = options.sessions || {};
    config.setKeepAliveMillis = options.setKeepAliveTime ? options.setKeepAliveTime : 1000;
    if (options.socketTimeout) config.socketTimeout = utils.setTimeOut(options.socketTimeout);
    else config.socketTimeout = utils.getTimeOut();
    if (deployEnv.isNotDev()) console.log('KeyMaker connection pool config constructed for Agent');
    return config;
}

// Construct configuration for Cryptoserv
function constructCryptoservConfig(options) {
    var config = {};
    config.poolName = 'Cryptoserv_Pool';
    config.host = options.host;
    config.port = options.port;
    config.min = options.csMinConn ? options.csMinConn : 0;
    config.max = options.csMaxConn ? options.csMaxConn : 10;
    config.isPoolLogEnabled = options.enablePoolLog ? options.enablePoolLog : false;
    config.credentials = options.credentials || {};
    config.sessions = options.sessions || {};
    config.reapIntervalMillis = options.freqToCheckIdle ? options.freqToCheckIdle : 60000;
    config.idleTimeoutMillis = options.idleTimeOut ? options.idleTimeOut : 180000;
    config.setKeepAliveMillis = options.setKeepAliveTime ? options.setKeepAliveTime : 60000;
    if (options.socketTimeout) config.socketTimeout = utils.setTimeOut(options.socketTimeout);
    else config.socketTimeout = utils.getTimeOut();
    if (deployEnv.isNotDev()) console.log('KeyMaker connection pool config constructed for Cryptoserv');
    return config;
}

/**
 * Create a TLSSocket using tls.connect()
 * Performs custom authetication after socket creation in case of connection to cryptoserv
 */
function createSocket(config, callback) {
    var calTxn = utils.createCalTransaction('CONNECT', config.host + ':' + config.port);
    if (calTxn) {
        calTxn.addData('MinValue', config.min);
        calTxn.addData('MaxValue', config.max);
    }
    tlsCredentials = {
    key: config.credentials.key,
    cert: config.credentials.cert,
    ca: config.credentials.ca,
    passphrase: config.credentials.passphrase,
    rejectUnauthorized: false
    };

    var session = config.sessions[utils.getSessionKeyName()];
    if (session) {
        tlsCredentials.session = new Buffer(session, 'base64');
    } else {
        utils.writeCalEvent('CONNECT_WARNING', 'CreateSocket', {
            error: 'No SSLResumption Session Data'
        }, 'WARNING');
    }

    var retry = 0;
    async.whilst(
        function () {                    
            return retry < 2; // retry once in case of error during tls.connect()
        },
        function (next) {
            var socket = tls.connect(config.port, config.host, tlsCredentials);
            socket.on('error', onError);
            socket.on('secureConnect', onConnect);
            socket.on('close', onError);
            function onError(error) {
                socket.removeAllListeners();
                // Write error notifying TLS Connect failure
                reportConnectStatus(calTxn, retry, 'CONNECT_FAILURE', error);
                
                retry++;
                next();
            }
            function onConnect() {
                socket.removeAllListeners();

                debug('KeyMakerClient is Creating Connections for pool %s', config.poolName);
                // On receipt of connect event we are sure that connection establishment went through fine
                // We set the timeout and keepalive values and return the socket in the callback to the pool.
                socket.setTimeout(config.socketTimeout);
                socket.setKeepAlive(true, config.setKeepAliveMillis);
                
                // Check if cryptoserv pool - custom auth needed
                if(config.poolName !== 'Cryptoserv_Pool') {
                    reportConnectStatus(calTxn, retry);
                    return callback(null, socket);
                }


                // Do custom auth
                doCustomAuth(socket, function(error) {
                    if(error) {
                        // Connection succeeded but auth failed
                        reportConnectStatus(calTxn, retry, 'AUTH_FAILURE', error);

                        // Destroy socket as auth failed, new socket needs to be created
                        socket.destroy();
                        retry++;
                        next();
                        return;
                    } else {
                        reportConnectStatus(calTxn, retry);
                        return callback(null, socket);
                    }
                });
            }
        },
        function () {
            // All errors are logged for each retry, reached here means retry exceeded max count
            console.error('Connection retries exceeded');
            return callback(new Error('Connection retries exceeded'), null);
        }
    );
}

// Destroy TLSSocket
function destroySocket(socket) {
    socket.destroy();
}

// Log connection status
function reportConnectStatus(calTxn, retry, failure_type, err){
    if (failure_type || err) { // connect failed
        console.error('Unexpected \'error\' Event Emitted %s - %s', failure_type, err, 'retry: ' + retry);
        if (calTxn) {
            calTxn.addData('Error', failure_type + ':' + err);
            calTxn.status = utils.getCalStatus();
        }
    } else { // connect succeeded
        if (calTxn)
            calTxn.status = utils.getCalStatus('success');
    }
    if (calTxn) {
        calTxn.addData('Connect_attempt', retry + 1);
        calTxn.complete();
    }
}

/**
 * Initialize netstring writer stream and bind it to socket
 * @param {TLSSocket} client 
 */
function init(client) {
    var nsWriter = NetString.writeStream();
    nsWriter.pipe(client);
    client.netStream = nsWriter;
}

/* ================================ Cryptoserv Custom Auth =================================== */

/**
 * Perform a handshake with cryptoserv : Hello Message -> get challenge -> respond to challenge
 * 
 * @param {TLSSocket} socket TLS connection established socket to perform Handshake on
 * @param {function} callback to be returned
 * 
 * @returns callback with error or auth status
 */
function doCustomAuth(socket, callback) {
    init(socket);
    
    async.waterfall([
        async.apply(initiateHandshake, socket),
        async.apply(responseToChallenge, socket),
    ], function (err, authStatus) {
         // Determine auth status
         socket.netStream.unpipe(socket);

        if(!err) {
            var command;
            if (authStatus) {
                // Check if auth is successful
                command = parseCSResponse(NetString.read(authStatus)[0]).command;
                if(command === CRYPTOSERV_CONNECTION_ACCEPTED)
                    return callback(null, 'SUCCESS');
            } else {
                command = "cryptoserv authentication failed";
            }
            err = getCSError(command);
        }
        return callback(err, null);
    });
} 

/**
 * Initiate Handshake with Cryptoserv
 * Cryptoserv would respond with a challenge: "SIZE:1001 some_random_challenge" 
 * which would go as input to next method in waterfall
 * 
 * @param {TLSSocket} client TLS connection established socket to perform Handshake on
 * @param {callback} next
 */
function initiateHandshake(client, next) {
    // Bind Events
    client.on('timeout', onTimeout);
    client.on('error', onError);
    client.on('data', onReceive);
    client.on('close', onClose);

    // Write Hello Message
    client.netStream.write(getHelloMessage());

    function onReceive(data) {
        // Remove listener and forward data
        client.removeAllListeners();
        return next(null, data);
    }

    function onError(error) {
        // Remove listener and report error
        client.removeAllListeners();
        return next(error, null);
    }

    function onTimeout() {
        // Remove listener and report error
        client.removeAllListeners();
        return next(new Error("timeout during handshake to cryptoserv"), null);
    }

    function onClose() {
        // Remove listener and report error
        client.removeAllListeners();
        return next(new Error("connection closed during handshake with cryptoserv"), null);
    }
}

/**
 * Read challenge from cryptoserv and respond to it
 * 
 * @param {TLSSocket} client TLS connection established socket to perform Handshake on
 * @param {Buffer} nsChallenge data from initiateHandshake() flowing here as a part of waterfall
 * @param {callback} next
 */
function responseToChallenge(client, nsChallenge, next) {
    var challengeRes = NetString.read(nsChallenge)[0];
    if(!challengeRes) {
        onError(new Error("Challenge is empty"));
        return;
    }
    var response = parseCSResponse(challengeRes);
    var command = response.command;

    // If valid session exists, client will be authenticated here
    if(command === CRYPTOSERV_CONNECTION_ACCEPTED)
        return next(null, nsChallenge);

    // Cryptoserv should challenge here with RANDOM_CHALLENGE_COMMAND
    if(command != RANDOM_CHALLENGE_COMMAND)
        return next(getCSError(command), null);
    
    /* Reached here means challenge is given */

    // Bind Events
    client.on('timeout', onTimeout);
    client.on('error', onError);
    client.on('data', onReceive);
    client.on('close', onClose);

    // Send challenge response
    var challengeResponse = getChallengeResponse(response.data);
    client.netStream.write(challengeResponse, 'binary');

    function onReceive(data) {
        // Remove listener and forward data
        client.removeAllListeners();
        return next(null, data);
    }

    function onError(error) {
        // Remove listener and report error
        client.removeAllListeners();
        return next(error, null);
    }

    function onTimeout() {
        // Remove listener and report error
        client.removeAllListeners();
        return next(new Error("timeout when responding to challenge"), null);
    }

    function onClose() {
        // Remove listener and report error
        client.removeAllListeners();
        return next(new Error("connection closed when responding to challenge"), null);
    }
}

/**
 * Utility function to parse response from cryptoserv of the form "COMMAND data"
 * 
 * @param {Buffer} response cryptoserv response after parsing netstring
 * 
 * @returns {JSON} Contains Integer command in response and binary Buffer with Data if any
 */
function parseCSResponse(response) {
    var SPACE_ASCII = 32;
    var length = response.length;

    for(var i = 0; i < length; i++) {

		if (response[i] === SPACE_ASCII) {
			var command = parseInt(response.toString(undefined, 0, i));
			var data = response.slice(i + 1, length);
			return {
                command: command,
                data: data
            };
		}
	}
    return {
        command: parseInt(response.toString(undefined, 0, length)),
    };
}

/**
 * Determine Error message based on command
 */
function getCSError(command) {
    var csError = (command in ERROR_MAP) ? ERROR_MAP[command] : 'UNKNOWN_ERROR';
    return (csError + ' ' + command);
}

/**
 * Compute respose to Cryptoserv challenge of the form "2004 hmac_of_challenge"
 * It is the SHA-256 HMAC using encrypted_auth_key
 * 
 * @param {Buffer} challenge random challenge data from cryptoserv
 * 
 * @returns {Buffer} binary challenge response
 */
function getChallengeResponse(challenge) {
    var auth_key = keyCache.getKeyFromCache(CHALLENGE_ENCRYPTION_KEY);
    var hmac = ppcryptutils.createHmac('sha256', auth_key.key, challenge);

    var commandBuffer = getBinaryBuffer(CHALLENGE_RESPONSE_COMMAND + ' ');
    var responseBuffer = Buffer.concat([commandBuffer, hmac]);

    return responseBuffer;
}

/**
 * Utility function to convert a string message to binary buffer
 * @param {String} stringMessage a message to be converted to a buffer with binary data in it
 * 
 * @returns {Buffer} binary encoded buffer
 */
function getBinaryBuffer(stringMessage) {
    return new Buffer(stringMessage.toString('binary'), 'binary');
}

/**
 * Form Cryptoserv HELLO message which is of the format
 *      LEN:COMMAND_ZERO LEN1:CRYPTOSERV_PROTOCOL_COMMAND CRYPTOSERV_PROTOCOL_NAME,
 *                       LEN2:CLIENT_USERNAME_COMMAND CLIENT_USERNAME,,
 * e.g. - 42:0 17:2002 cryptoserv 1,15:2003 stage1_web,,
 *
 * @returns {string} Hello Message
 */
function getHelloMessage() {
    var nsMessageProtocol = CRYPTOSERV_PROTOCOL_COMMAND + ' ' + CRYPTOSERV_PROTOCOL_NAME;
    var username;
    username = utils.getAppName() ? utils.getAppName() : utils.getProtectedUserName();
    var nsMessageUsername = CLIENT_USERNAME_COMMAND + ' ' + username;
    var nsMessageAC = CLIENT_APP_CTX_COMMAND + ' ' + utils.getAppContext();

    var nsHelloMessage = COMMAND_ZERO + ' ' +
        nsMessageProtocol.length + ':' + nsMessageProtocol + ',' +
        nsMessageUsername.length + ':' + nsMessageUsername + ',' +
        nsMessageAC.length + ':' + nsMessageAC + ',,';

    return nsHelloMessage;
}

module.exports = {
    constructAgentConfig: constructAgentConfig,
    constructCryptoservConfig: constructCryptoservConfig,
    createSocket: createSocket,
    destroySocket: destroySocket,
    getCSError: getCSError,
    parseCSResponse: parseCSResponse,
    getBinaryBuffer: getBinaryBuffer,
    init: init
}