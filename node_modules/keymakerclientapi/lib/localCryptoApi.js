'use strict';
var assert = require('assert'),
    base64 = require('base64-paypal'),
    crypto = require('crypto'),
    debug = require('debuglog')('kmsclientdebug'),
    keyStore = require('./KeyCache'),
    ObjectIdEncryptor = require('objectidencryptor'),
    ppcryptutils = require('cryptutils-paypal'),
    utils = require('./utils');

var CAL_PROTECTED_TRANSACTION = 'protected_';

function getAlgoBasedOnCryptKeyName(keyId, key) {
    var algo;
    assert.ok(keyId, 'LocalCryptoModule-getAlgoBasedOnCryptKeyName: keyId is needed when algoname is not populated from cache.');
    assert.ok(key, 'LocalCryptoModule-getAlgoBasedOnCryptKeyName: keyMaterial is required.');
    if (!/_crypt_key$/i.test(keyId)) throw new Error('LocalCryptoModule-getAlgoBasedOnCryptKeyName: keyId not ending with _crypt_key not supported.');
    switch (key.length) {
        case 8:
            algo = 'des_cbc_nopad';
            break;
        case 16:
            algo = 'aes_128_cbc_nopad';
            break;
        case 20:
            algo = 'desx_cbc_nopad';
            break;
        case 24:
            algo = 'desx_cbc_nopad';
            break;
        case 32:
            algo = 'aes_256_cbc_nopad';
            break;
        default:
            throw new Error('Unable to determine algo from the keyId ' + keyId);
    }
    return algo;
}

function getAlgoBasedOnMacKey(macKey) {
    var algo;
    if (!macKey) throw new Error('LocalCryptoModule-getAlgoBasedOnMacKey: macKey is required.');
    if (macKey.length === 32) algo = 'sha256';
    else algo = 'sha1';
    return algo;
}

function getCryptoDetailsFromAlgoName(params) {
    assert.strictEqual(params && typeof params, 'object', 'LocalCryptoModule-getCryptoDetailsFromAlgoName: expected a params object');
    assert.ok(params.operation, 'LocalCryptoModule-getCryptoDetailsFromAlgoName: params.operation cannot be null');
    var cryptDetails = {},
        nopadIndex,
        randomIVIndex,
        pkcs5paddingIndex,
        algoLowerCase;
    cryptDetails.algoName = 'desx';
    cryptDetails.padding = true;
    cryptDetails.randomIV = false;
    cryptDetails.key;
    cryptDetails.iv;
    if (params.algo) algoLowerCase = params.algo.toLowerCase();
    else {
        if (params.operation === 'encrypt' || params.operation === 'decrypt') {
            algoLowerCase = getAlgoBasedOnCryptKeyName(params.cryptKeyName, params.cryptKey);
        } else if (params.operation === 'hmac') {
            algoLowerCase = getAlgoBasedOnMacKey(params.macKey);
        }
    }
    cryptDetails.algoName = algoLowerCase; //Setting default algoName to be the input itself
    // Beyond this point, it doesn't make sense to have an undefined value for 'algoLowerCase'
    if (!algoLowerCase) throw new Error('LocalCryptoModule-getCryptoDetailsFromAlgoName: algoname is undefined, probably algo not found in cache');
    nopadIndex = algoLowerCase.indexOf('nopad');
    randomIVIndex = algoLowerCase.indexOf('random_iv');
    pkcs5paddingIndex = algoLowerCase.indexOf('pkcs5padding');
    if (randomIVIndex !== -1) {
        cryptDetails.randomIV = true;
        cryptDetails.algoName = algoLowerCase.substring(0, randomIVIndex - 1).replace(/_/g, '-');
    }
    if (nopadIndex !== -1) {
        cryptDetails.padding = false;
        cryptDetails.algoName = algoLowerCase.substring(0, nopadIndex - 1).replace(/_/g, '-');
    } else if (pkcs5paddingIndex !== -1) {
        cryptDetails.padding = true;
        cryptDetails.algoName = algoLowerCase.substring(0, pkcs5paddingIndex - 1).replace(/_/g, '-');
    }
    switch (params.operation) {
        case 'seal':
        case 'unseal':
            computeSealUnsealDetails(params, cryptDetails);
            break;
        case 'hmac':
            computeHmacDetails(params, cryptDetails, algoLowerCase);
            break;
        case 'encrypt':
        case 'decrypt':
            computeEncDecDetails(params, cryptDetails, algoLowerCase);
            break;
        default:
            throw new Error('Unsupported operation: ' + params.operation);
    }
    return cryptDetails;
}

function computeSealUnsealDetails(params, cryptDetails) {
    var supported_SHA1_Algos = ['sha1', 'hmac_sha_1', 'hmacsha1_1','sha1_hashed_key'];
    var supported_SHA2_Algos = ['sha256', 'hmacsha256_256', 'hmac_sha_256'];
    if (/^desx/i.test(cryptDetails.algoName)) cryptDetails.algoName = 'desx';
    else if (/^tripledes/i.test(cryptDetails.algoName)) cryptDetails.algoName = 'des-ede3-cbc';
    else if (/^aes-128-cbc/i.test(cryptDetails.algoName)) cryptDetails.algoName = 'aes128';
    else throw new Error('Unrecognized Crypt Algorithm: ' + cryptDetails.algoName + ' Did not start with DESX or TRIPLEDES or AES_128_CBC');
    // Get the MacKey Algo Name
    if (supported_SHA1_Algos.indexOf(params.macAlgo.toLowerCase()) !== -1) cryptDetails.macAlgoName = 'sha1';
    else if (supported_SHA2_Algos.indexOf(params.macAlgo.toLowerCase()) !== -1) cryptDetails.macAlgoName = 'sha256';
    else throw new Error('Unrecognized Mac Algorithm: ' + params.macAlgo);
}

function computeHmacDetails(params, cryptDetails, algo) {
    if (!/sha/i.test(algo)) {
        throw new Error('LocalCryptoModule-computeHmacDetails: unexpected hmac algorithm');
    }
    if (params.cryptKeyAlgo === 'DESX_CBC_NOPAD') {
        assert.ok(params.macKey, 'LocalCryptoModule-computeHmacDetails: macKey mandatory to perform HMAC.');
        cryptDetails.key = crypto.createHash('sha1').update(params.macKey.slice(0, 20)).digest();
    } else cryptDetails.key = params.macKey;

    switch (algo) {
        case 'sha1':
        case 'hmacsha1_1':
        case 'hmac_sha_1':
            cryptDetails.algoName = 'sha1';
            break;
        case 'sha1_hashed_key':
            assert.ok(params.macKey, 'LocalCryptoModule-computeHmacDetails: macKey mandatory to perform HMAC.');
            cryptDetails.algoName = 'sha1';
            // handle special case by re-setting cryptDetails.key to computed macKey
            cryptDetails.key = crypto.createHash('sha1').update(params.macKey.slice(0, 20)).digest();
            break;
        case 'sha256':
        case 'hmacsha256_256':
        case 'hmac_sha_256':
            cryptDetails.algoName = 'sha256';
            break;
        case 'sha384':
        case 'hmac_sha_384':
            cryptDetails.algoName = 'sha384';
            break;
        case 'sha512':
        case 'hmac_sha_512':
            cryptDetails.algoName = 'sha512';
            break;
        default:
            throw new Error('Unsupported HMAC operation: ' + algo);
    }
}

function computeEncDecDetails(params, cryptDetails, algoName) {
    // We expect params.cryptKey has a mandatory requirement for most basic encrypt/decrypt algos
    assert.ok(params.cryptKey, 'LocalCryptoModule-computeEncDec: cryptKey mandatory for encrypt/decrypt operation.');
    var keyMaterial;
    switch (algoName) {
        case 'desx_cbc_nopad':
            keyMaterial = crypto.createHash('sha1').update(params.cryptKey.slice(0, 20)).digest();
            cryptDetails.key = Buffer.concat([keyMaterial.slice(0, 16), keyMaterial.slice(12, 20)]);
            break;
        case 'desx_cbc_nopad_iv_from_mac':
            cryptDetails.key = params.cryptKey.slice(0, 24);
            cryptDetails.iv = params.macKey;
            break;
        case 'desx_cbc_nopad_hashed_key':
            assert.ok(params.macKey, 'LocalCryptoModule-computeEncDec: macKey mandatory for DESX_CBC_NOPAD_HASHED_KEY.');
            keyMaterial = crypto.createHash('sha1').update(params.cryptKey.slice(0, 16)).digest();
            cryptDetails.key = Buffer.concat([keyMaterial.slice(0, 16), keyMaterial.slice(-8)]);
            cryptDetails.iv = params.macKey.slice(0, 8);
            break;
        case 'desx_cbc_nopad_hashed_key_hashed_iv':
            assert.ok(params.macKey, 'LocalCryptoModule-computeEncDec: macKey mandatory for DESX_CBC_NOPAD_HASHED_KEY_HASHED_IV.');
            keyMaterial = crypto.createHash('sha1').update(params.cryptKey.slice(0, 16)).digest();
            cryptDetails.key = Buffer.concat([keyMaterial.slice(0, 16), keyMaterial.slice(-8)]);
            cryptDetails.iv = crypto.createHash('sha1').update(params.macKey).digest().slice(0, 8);
            break;
        case 'desx':
            cryptDetails.key = params.cryptKey;
            cryptDetails.iv = params.macKey;
            break;
        case 'aes_256_cbc_nopad_random_iv':
        case 'aes_128_cbc_nopad_random_iv':
        case 'aes_128_cbc_pkcs5padding_random_iv':
        case 'aes_256_cbc_pkcs5padding_random_iv':
            cryptDetails.key = params.cryptKey;
            if (/256/g.test(cryptDetails.algoName) && cryptDetails.key.length !== 32) {
                throw new Error('LocalCryptoModule-computeEncDec: Expected key size is 32');
            } else if (/128/g.test(cryptDetails.algoName) && cryptDetails.key.length !== 16) {
                throw new Error('LocalCryptoModule-computeEncDec: Expected key size is 16');
            }
            if (params.operation === 'decrypt') {
                cryptDetails.cipherData = params.cipherData.slice(16);
                cryptDetails.iv = params.cipherData.slice(0, 16);
            } else {
                cryptDetails.iv = crypto.randomBytes(16);
            }
            break;
        case 'aes_128_cbc_nopad':
        case 'aes_256_cbc_nopad':
        case 'aes_128_cbc_nopad_noiv':
        case 'aes_256_cbc_nopad_noiv':
            cryptDetails.key = params.cryptKey;
            if (/256/g.test(cryptDetails.algoName) && cryptDetails.key.length !== 32) {
                throw new Error('LocalCryptoModule-computeEncDec: Expected key size is 32');
            } else if (/128/g.test(cryptDetails.algoName) && cryptDetails.key.length !== 16) {
                throw new Error('LocalCryptoModule-computeEncDec: Expected key size is 16');
            }
            break;
        case 'tripledes_cbc_nopad':
            cryptDetails.key = params.cryptKey;
            cryptDetails.algoName = 'des-ede3-cbc';
            break;
        case 'des_cbc_nopad':
            cryptDetails.key = params.cryptKey;
            // ::ToDo:: Have to check with agent code to validate
            break;
        case 'aes_128_gcm_nopad_random_iv':
        case 'aes_256_gcm_nopad_random_iv':
            var ivSize = 12;
            if (params.operation === 'encrypt') {
                cryptDetails.key = params.cryptKey;
                cryptDetails.iv = crypto.randomBytes(ivSize);
            } else {
                cryptDetails.key = params.cryptKey;
                cryptDetails.version = params.cipherData.slice(0, 2);
                cryptDetails.iv = params.cipherData.slice(2, ivSize + 2);
                cryptDetails.tag = params.cipherData.slice(ivSize + 2, ivSize + 2 + 16);
                cryptDetails.cipherData = params.cipherData.slice(ivSize + 2 + 16);
            }
            break;
        default:
            throw new Error('Unsupported encrypt/decrypt algorithm trait: ' + params.algo.toUpperCase());
    }
}

function aes_gcm_encrypt(payload, algo, key, iv, version) {
    // Fill Buffer with 2 bytes to represent version as
    // signed integer (js number) big endian
    var verBuf = new Buffer(2);
    verBuf.fill(0);
    verBuf.writeInt16BE(version, 0);

    var cipher = crypto.createCipheriv(algo, key, iv);
    if (typeof cipher.setAAD === 'undefined') throw new Error('Local aes_gcm_encrypt is not supported in node v0.10.x and below');
    cipher.setAAD(verBuf);

    var cipherText = Buffer.concat([cipher.update(payload),cipher.final()]);
    var tag = cipher.getAuthTag();
    var encryptedDataBuffer = Buffer.concat([verBuf, iv, tag, cipherText]);

    return encryptedDataBuffer;
}

function aes_gcm_decrypt(encryptedData, tag, algo, key, iv, verBuf) {
    var decipher = crypto.createDecipheriv(algo, key, iv);
    if (typeof decipher.setAAD === 'undefined') throw new Error('Local aes_gcm_decrypt is not supported in node v0.10.x and below');
    decipher.setAuthTag(tag);
    decipher.setAAD(verBuf);

    var plainTextBuffer = Buffer.concat([decipher.update(encryptedData), decipher.final()]);

    return plainTextBuffer;
}

function encryptLocalKeyCache(keyData, inputData) {
    var calTxn = utils.createCalTransaction('Encrypting local key cache');
    try {
        if (!keyData || !inputData) {
            throw new Error('LocalCryptoModule: keyData and inputData is mandatory for encrypting local key cache');
        }
        var cryptDetails, params = {}, encryptedDataBuffer;
        params.cryptKey = keyData;
        params.algo = 'aes_128_gcm_nopad_random_iv';
        params.operation = 'encrypt';

        cryptDetails = getCryptoDetailsFromAlgoName(params);
        debug(cryptDetails);
        if(!cryptDetails) return null;

        if(/gcm/i.test(cryptDetails.algoName)) {
             debug('encrypting local key cache using aes-gcm');
             encryptedDataBuffer = aes_gcm_encrypt(inputData, cryptDetails.algoName, cryptDetails.key, cryptDetails.iv, 0);  // TODO: check version
        }
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        return utils.getResponseObj(base64.encode(encryptedDataBuffer).toString(), 'encrypt', 'b64_aes_key');
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function decryptLocalKeyCache(keyData, cipherData) {
    var calTxn = utils.createCalTransaction('Decrypting local key cache');
    try {
        if (!keyData || !cipherData) {
            throw new Error('LocalCryptoModule: keyData and cipherData is mandatory for decrypting local key cache');
        }
        var cryptDetails, params = {}, decryptedData;
        params.cryptKey = keyData;
        params.algo = 'aes_128_gcm_nopad_random_iv';
        params.operation = 'decrypt';
        params.cipherData = cipherData;
        cryptDetails = getCryptoDetailsFromAlgoName(params);
        debug(cryptDetails);
        if (!cryptDetails) return null;
        if (cryptDetails.cipherData)
            cipherData = cryptDetails.cipherData;
        if (/gcm/i.test(cryptDetails.algoName)) {
            debug('decrypting local key cache using aes-gcm');
            decryptedData = aes_gcm_decrypt(cipherData, cryptDetails.tag, cryptDetails.algoName, cryptDetails.key, cryptDetails.iv, cryptDetails.version); // TODO: check version
        }
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        var res = utils.getResponseObj(base64.encode(decryptedData).toString(), 'decrypt', 'b64_aes_key');
        // Adding decrypted data as plainData to the response object.
        res.result.plainData = decryptedData;
        return res;
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function encrypt(keyId, inputData) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'encrypt', keyId);
    try {
        if (!keyId || !inputData) {
            throw new Error('LocalCryptoModule: keyId and inputData is mandatory for encrypt');
        }
        var cryptDetails, params = {};
        params.cryptKeyName = keyId;
        var keyObj = keyStore.getKeyFromCache(keyId);
        if (keyObj.cache === 'nosupport') {
            if (calTxn) calTxn.status = utils.getCalStatus('success');
            throw new Error('LocalCryptoModule: Support for Asymmetric crypto operations only by agent so falling back.');
        }
        params.cryptKey = keyObj.key;
        if (calTxn) calTxn.addData('cache', keyObj.cache);
        params.macKey = keyStore.getKeyFromCache(keyId.replace('crypt_key', 'mac_key')).key;
        params.algo = keyStore.getAlgoFromCache(utils.createSubKey(keyId) + '_algo').algo;
        params.operation = 'encrypt';
        cryptDetails = getCryptoDetailsFromAlgoName(params);
        debug(cryptDetails);
        if (!cryptDetails) return null;

        var encryptedDataBuffer;

        if (/gcm/i.test(cryptDetails.algoName)) {
            debug('performing aes-gcm encrypt');
            var gcmKeyVersion;
            if (keyObj.hasOwnProperty('version')) {
                gcmKeyVersion = keyObj.version;
            }
            if (!gcmKeyVersion) throw new Error('Unable to retrieve version from keyCache to perform gcm-encrypt');
            encryptedDataBuffer = aes_gcm_encrypt(inputData, cryptDetails.algoName, cryptDetails.key, cryptDetails.iv, gcmKeyVersion);
        } else {
            debug('performing non-gcm encrypt');
            encryptedDataBuffer = ppcryptutils.createCipherSpec(cryptDetails.algoName, cryptDetails.key, cryptDetails.padding, cryptDetails.iv).cipher(inputData);
            if (cryptDetails.randomIV === true) {
                encryptedDataBuffer = Buffer.concat([cryptDetails.iv, encryptedDataBuffer]);
            }
        }
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        return utils.getResponseObj(base64.encode(encryptedDataBuffer).toString(), 'encrypt', keyId);
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function decrypt(keyId, cipherData) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'decrypt', keyId);
    try {
        if (!keyId || !cipherData) {
            throw new Error('LocalCryptoModule: keyId and cipherData is mandatory for decrypt');
        }
        var cryptDetails, params = {};
        params.cryptKeyName = keyId;
        var keyObj = keyStore.getKeyFromCache(keyId);
        if (keyObj.cache === 'nosupport') {
            if (calTxn) calTxn.status = utils.getCalStatus('success');
            throw new Error('LocalCryptoModule: Support for Asymmetric crypto operations only by agent so falling back.');
        }
        params.cryptKey = keyObj.key;
        if (calTxn) calTxn.addData('cache', keyObj.cache);
        params.macKey = keyStore.getKeyFromCache(keyId.replace('crypt_key', 'mac_key')).key;
        params.algo = keyStore.getAlgoFromCache(utils.createSubKey(keyId) + '_algo').algo;
        params.operation = 'decrypt';
        params.cipherData = cipherData;
        cryptDetails = getCryptoDetailsFromAlgoName(params);
        debug(cryptDetails);
        if (!cryptDetails) return null;
        if (cryptDetails.cipherData) {
            cipherData = cryptDetails.cipherData;
        }

        var decryptedData;

        if (/gcm/i.test(cryptDetails.algoName)) {
            debug('performing aes-gcm decrypt');
            if (!cryptDetails.hasOwnProperty('version')) throw new Error('Unable to retrieve version from cipherData');
            var gcmKeyVersion;
            if (keyObj.hasOwnProperty('version')) {
                gcmKeyVersion = keyObj.version;
            }
            if (!gcmKeyVersion) throw new Error('Unable to retrieve version from keyCache to perform gcm-decrypt');

            var versionFromCipher = cryptDetails.version.readInt16BE(0);
            if (versionFromCipher !== gcmKeyVersion) {
                throw new Error('Data Encrypted with Version ' +
                                versionFromCipher +
                                ' ,trying decrypt with Version ' +
                                gcmKeyVersion.toString());
            }
            decryptedData = aes_gcm_decrypt(cipherData, cryptDetails.tag, cryptDetails.algoName, cryptDetails.key, cryptDetails.iv, cryptDetails.version);
        } else {
            debug('performing non-gcm decrypt');
            decryptedData = ppcryptutils.createCipherSpec(cryptDetails.algoName, cryptDetails.key, cryptDetails.padding, cryptDetails.iv).decipher(cipherData);
        }
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        var res = utils.getResponseObj(base64.encode(decryptedData).toString(), 'decrypt', keyId);
        // Adding decrypted data as plainData to the response object.
        res.result.plainData = decryptedData;
        return res;
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function hmac(keyId, inputData) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'hmac', keyId);
    try {
        if (!keyId || !inputData) {
            throw new Error('LocalCryptoModule: keyId and inputData is mandatory for encrypt');
        }
        var cryptDetails, params = {};
        var keyObj = keyStore.getKeyFromCache(keyId);
        params.macKey = keyObj.key;
        params.algo = keyStore.getAlgoFromCache(utils.createSubKey(keyId) + '_algo').algo;
        if (/_mac_key$/i.test(keyId)) {
            params.cryptKeyAlgo = keyStore.getAlgoFromCache(utils.createSubKey(keyId.replace(/_mac_key/, '_crypt_key')) + '_algo').algo;
        }
        if (calTxn) calTxn.addData('cache', keyObj.cache);
        params.operation = 'hmac';
        cryptDetails = getCryptoDetailsFromAlgoName(params);
        debug(cryptDetails);
        if (!cryptDetails) return null;
        var hmac = ppcryptutils.createHmac(cryptDetails.algoName, cryptDetails.key, inputData);
        var version = keyStore.getVersionFromCache(utils.createSubKey(keyId) + '_version');
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        return utils.getResponseObj(base64.encode(hmac).toString(), 'hmac', keyId, null, version.version);
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function seal(cryptKeyId, macKeyId, inputData) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'seal', cryptKeyId);
    try {
        if (!cryptKeyId || !macKeyId || !inputData) {
            throw new Error('LocalCryptoModule: keyId and inputData is mandatory for encrypt');
        }
        var cryptDetails, params = {};
        params.operation = 'seal';
        params.algo = keyStore.getAlgoFromCache(utils.createSubKey(cryptKeyId) + '_algo').algo;
        params.macAlgo = keyStore.getAlgoFromCache(utils.createSubKey(macKeyId) + '_algo').algo;

        var encryptionKeyObj = keyStore.getKeyFromCache(cryptKeyId);
        var cryptKeyMaterial = encryptionKeyObj.key;
        if (!cryptKeyMaterial) throw new Error('LocalCryptoModule-seal: cryptKey material is required');

        var macKeyObj = keyStore.getKeyFromCache(macKeyId);
        var macKeyMaterial = macKeyObj.key;
        if (!macKeyMaterial) throw new Error('LocalCryptoModule-seal: macKey material is required');

        cryptDetails = getCryptoDetailsFromAlgoName(params);
        debug(cryptDetails);
        if (!cryptDetails) return null;

        var configuration = {
            encryptionAlgorithm: cryptDetails.algoName,
            macAlgorithm: cryptDetails.macAlgoName,
            encryptionKey: cryptKeyMaterial,
            macKey: macKeyMaterial
        };
        if (calTxn) {
            calTxn.addData('cache[cryptKey]', encryptionKeyObj.cache);
            calTxn.addData('cache[macKey]', macKeyObj.cache);
        }
        var sealedData = ppcryptutils(configuration).seal(inputData);
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        return utils.getResponseObj(base64.encode(sealedData).toString(), 'seal', cryptKeyId, macKeyId);
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function unseal(cryptKeyId, macKeyId, sealedData) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'unseal', cryptKeyId);
    try {
        if (!cryptKeyId || !macKeyId || !sealedData) {
            throw new Error('LocalCryptoModule: keyId and inputData is mandatory for encrypt');
        }
        var cryptDetails, params = {};
        params.operation = 'unseal';
        params.algo = keyStore.getAlgoFromCache(utils.createSubKey(cryptKeyId) + '_algo').algo;
        params.macAlgo = keyStore.getAlgoFromCache(utils.createSubKey(macKeyId) + '_algo').algo;

        var encryptionKeyObj = keyStore.getKeyFromCache(cryptKeyId);
        var cryptKeyMaterial = encryptionKeyObj.key;
        if (!cryptKeyMaterial) throw new Error('LocalCryptoModule-unseal: cryptKey material is required');

        var macKeyObj = keyStore.getKeyFromCache(macKeyId);
        var macKeyMaterial = macKeyObj.key;
        if (!macKeyMaterial) throw new Error('LocalCryptoModule-unseal: macKey material is required');

        cryptDetails = getCryptoDetailsFromAlgoName(params);
        debug(cryptDetails);
        if (!cryptDetails) return null;

        var configuration = {
            encryptionAlgorithm: cryptDetails.algoName,
            macAlgorithm: cryptDetails.macAlgoName,
            encryptionKey: cryptKeyMaterial,
            macKey: macKeyMaterial
        };
        if (calTxn) {
            calTxn.addData('cache[cryptKey]', encryptionKeyObj.cache);
            calTxn.addData('cache[macKey]', macKeyObj.cache);
        }
        var unSealedData = ppcryptutils(configuration).unseal(new Buffer(base64.decode(sealedData)));
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        var res = utils.getResponseObj(base64.encode(unSealedData).toString(), 'unseal', cryptKeyId, macKeyId);
        res.result.plainData = unSealedData;
        return res;
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function getSecret(keyId) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'nonkey', keyId);
    try {
        if (!keyId) {
            throw new Error('LocalCryptoModule: keyId is mandatory for getSecret');
        }
        var keyObj = keyStore.getKeyFromCache(keyId);
        if (keyObj.key) {
            var typeObj = keyStore.getTypeFromCache(keyId);
            if (typeObj.type !== 'nonkey') {
                throw new Error('LocalCryptoModule: key ' + keyId + ' is not a secret');
            }
        }
        if (calTxn) calTxn.addData('cache', keyObj.cache);
        var secretData = keyObj.key;
        if (calTxn) calTxn.status = utils.getCalStatus('success');
        var res = utils.getResponseObj(base64.encode(secretData).toString(), 'getSecret', keyId);
        res.result.plainData = secretData;
        return res;
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function ObjectIdEncrypt(data, config) {
    if (!data) throw new Error('ObjectIDEncryptor-encrypt: Expects mandatory data param');
    if (!config) throw new Error('ObjectIDEncryptor-encrypt: Expects mandatory config param');
    if (!config.key && !config.keyName) throw new Error('ObjectIDEncryptor-encrypt: keyName required');
    try {
        var txnName = !config.keyName ? 'no_keyname_provided' : config.keyName;
        var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'objectid_encrypt', txnName);
        var encryptedId;
        if (config.key) { //Following legacy way if the user is still providing the key himself
            if (calTxn) calTxn.addData('nocache', 'Legacy');
            encryptedId = ObjectIdEncryptor.encrypt(data, {
                key: config.key,
                iv: config.iv,
                keyName: config.keyName,
                ivName: config.ivName,
                type: config.type
            });
            if (calTxn) calTxn.status = utils.getCalStatus('success');
            return encryptedId;
        } else if (config.keyName) { //User not providing key but providing keyName as expected
            var params = {},
                keyName = config.keyName;
            params.cryptKeyName = keyName;
            var keyObj = keyStore.getKeyFromCache(keyName);
            params.cryptKey = keyObj.key;
            if (calTxn) calTxn.addData('cache', keyObj.cache);
            params.macKey = keyStore.getKeyFromCache(keyName.replace('crypt_key', 'mac_key')).key;
            params.algo = keyStore.getAlgoFromCache(utils.createSubKey(keyName) + '_algo').algo;

            encryptedId = ObjectIdEncryptor.encrypt(data, {
                key: params.cryptKey,
                iv: params.macKey,
                keyName: keyName,
                ivName: config.ivName,
                type: config.type
            });
            if (calTxn) calTxn.status = utils.getCalStatus('success');
            return encryptedId;
        }
    } catch (e) {
        if (calTxn) calTxn.addData('ObjectIDEncryptorEncryptException:', e);
        return null;
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function ObjectIdDecrypt(data, config) {
    if (!data) throw new Error('ObjectIDEncryptor-decrypt call expects mandatory data param');
    if (!config) throw new Error('ObjectIDEncryptor-decrypt call expects mandatory config param');
    if (!config.key && !config.keyName) throw new Error('ObjectIDEncryptor-encrypt: keyName required');
    try {
        var txnName = !config.keyName ? 'no_keyname_provided' : config.keyName;
        var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'objectid_decrypt', txnName);
        var decryptedId;
        if (config.key) { //Following legacy way if the user is still providing the key himself
            if (calTxn) calTxn.addData('nocache', 'Legacy');
            decryptedId = ObjectIdEncryptor.decrypt(data, {
                key: config.key,
                iv: config.iv,
                keyName: config.keyName,
                ivName: config.ivName,
                type: config.type
            });
            if (calTxn) calTxn.status = utils.getCalStatus('success');
            return decryptedId;
        } else if (config.keyName) {
            var params = {},
                keyName = config.keyName;
            params.cryptKeyName = keyName;
            var keyObj = keyStore.getKeyFromCache(keyName);
            params.cryptKey = keyObj.key;
            if (calTxn) calTxn.addData('cache', keyObj.cache);
            params.macKey = keyStore.getKeyFromCache(keyName.replace('crypt_key', 'mac_key')).key;
            params.algo = keyStore.getAlgoFromCache(utils.createSubKey(keyName) + '_algo').algo;

            decryptedId = ObjectIdEncryptor.decrypt(data, {
                key: params.cryptKey,
                iv: params.macKey,
                keyName: keyName,
                ivName: config.ivName,
                type: config.type
            });
            if (calTxn) calTxn.status = utils.getCalStatus('success');
            return decryptedId;
        }
    } catch (e) {
        if (calTxn) calTxn.addData('ObjectIDEncryptorEncryptException:', e);
        return null;
    } finally {
        if (calTxn) calTxn.complete();
    }
}

function getOutBoundExternalSSLConfig(keyStoreName, externalSSLConfig) {
    try {
        var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'sslconfig_outbound', keyStoreName);
        assert.ok(keyStoreName, 'keyCache-getKeyMakerKeyStoreCache: keyStoreName cannot be null');
        // Get the keystore from the local in-memory cache
        var keymakerKeyStore = keyStore.getKMKeyStoreCache(keyStoreName);

        if (!keymakerKeyStore ||  Object.keys(keymakerKeyStore).length === 0) {
            throw new Error('KMKeyStore not Found or empty in local in-memory cache');
        }
        // keymakerkeystore properties were hard-set irrespective of their presence hence no validation required.
        // If anything goes wrong with the multi-level property access, exception gets caught in catch block
        // and we would end up falling back on the agent.

        // Processing trustedCerts
        var trustedCertsList_NonPEM = keymakerKeyStore.trustedCerts;

        if (!trustedCertsList_NonPEM ||  Object.keys(trustedCertsList_NonPEM).length === 0) {
            throw new Error('undesirable to have trustedCerts empty');
        }
        var trustedCertsList_PEM = [];

        for (var i = 0; i < trustedCertsList_NonPEM.length; i++) {
            var formattedCert = utils.convertToPEMFormat(trustedCertsList_NonPEM[i], i);
            trustedCertsList_PEM.push(formattedCert);
        }
        externalSSLConfig.result.trustedCerts = trustedCertsList_PEM;

        // Processing protocol version
        externalSSLConfig.result.protocolVer = keymakerKeyStore.protocolVer;
        if (!externalSSLConfig.result.protocolVer) {
            throw new Error('undesirable to have protocolVer empty');
        }
        // Processing supported cipherSuites
        externalSSLConfig.result.cipherSuites = keymakerKeyStore.cipherSuites;
        if (!externalSSLConfig.result.cipherSuites) {
            throw new Error('undesirable to have cipherSuites empty');
        }
        // Processing private Key
        var privateKey = keymakerKeyStore.privateKey;
        if (!privateKey) {
            // Not mandatory and can be empty
            if (calTxn) calTxn.addData('privateKey', 'notFound');
            externalSSLConfig.result.privateKey = undefined;
        } else {
            if (privateKey.constructor === Array) {
                throw new Error('privateKey cannot be a list, should be single');
            }
            var formattedKey = utils.convertToPEMFormat(privateKey);
            externalSSLConfig.result.privateKey = formattedKey;
        }
        // Processing public certs
        var publicCertsList_NonPEM = keymakerKeyStore.publicCerts;
        if (!publicCertsList_NonPEM ||  Object.keys(publicCertsList_NonPEM).length === 0) {
            // Not mandatory and can be empty.
            if (calTxn) calTxn.addData('publicCerts', 'notFound');
            externalSSLConfig.result.publicCerts = undefined;
        } else {
            var publicCertsList_PEM = [];
            for (var j = 0; j < publicCertsList_NonPEM.length; j++) {
                var formattedPublicCert = utils.convertToPEMFormat(publicCertsList_NonPEM[j], j);
                publicCertsList_PEM.push(formattedPublicCert);
            }
            externalSSLConfig.result.publicCerts = publicCertsList_PEM;
        }

        if (calTxn) calTxn.status = utils.getCalStatus('success');
    } catch (e) {
        throw new Error('CryptoException-' + e);
    } finally {
        if (calTxn) calTxn.complete();
    }
}

module.exports = {
    encrypt: encrypt,
    decrypt: decrypt,
    hmac: hmac,
    seal: seal,
    unseal: unseal,
    getSecret: getSecret,
    ObjectIdEncrypt: ObjectIdEncrypt,
    ObjectIdDecrypt: ObjectIdDecrypt,
    getOutBoundExternalSSLConfig: getOutBoundExternalSSLConfig,
    encryptLocalKeyCache: encryptLocalKeyCache,
    decryptLocalKeyCache: decryptLocalKeyCache
};
