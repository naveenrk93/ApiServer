'use strict';
var assert = require('assert'),
    debug = require('debuglog')('kmsclientdebug'),
    utils = require('./utils'),
    csUtils = require('./cryptoservUtils'),
    ConnectionPool = require('./connectionPool'),
    vault = require('vault'),
    Dict = require('collections/dict'),
    NetString = require('netstring-stream'),
    pem2jwk = require('pem-jwk').pem2jwk,
    pem = require('pem'),
    fs = require('fs'),
    Path = require('path'),
    shush = require('shush'),
    jose = require('node-jose'),
    Long = require('long');
    var https = require('https');
// PayPal Modules
var base64 = require('base64-paypal'),
    deployEnv = require('environment-paypal'),
    infraCryptoAPIProvider = require('./InfraCryptoAPIProvider').cryptoProvider,
    keyStore = require('./KeyCache'),
    keyMakerprops = require('./KeyMakerProperties'),
    localCrypto = require('./localCryptoApi');
// vars used in code
var pool,
    cryptoservPool,
    kmsclient,
    infraCryptoClient,
    instantiated = false,
    isInvokedMultipleTimes = false,
    isAgentEnabled = true,
    isKeyMaker_HardFailure_Enabled = false,
    keyCachePath,
    kek,
    pin,
    moduleConfig = {},
    CAL_KEYMAKER_TRANSACTION = 'keymaker_',
    BOOTSTRAP_FAILURE_MSG = '-KEYMAKER BOOTSTRAP UNSUCCESSFUL-',
    KEY_EXPORT_FAILURE_MSG = 'km_init_step2_',
    ks = {},
    GET_CLIENT_ERR_MSG = 'Critical Failure-KeyMaker Bootstrap was Incomplete- ',
    appName = utils.getAppName();
var CAL_PROTECTED_TRANSACTION = 'protected_';
const APP_CTX_NA = "APP_CTX_NA";

function buildOptions(operation, correlationId, params) {
    var options = {};
    options.operation = operation;
    options.correlation_id = correlationId;
    options.version = moduleConfig.version;
    options.app_name = moduleConfig.appname;
    options.secret = moduleConfig.secret;
    options.params = {};
    if (operation === 'get_exportable_keys') {
        return options;
    }
    if (!params.keyId) {
        if (!params.macKeyId && !params.cryptKeyId) {
            assert(params.keyId, 'keyId/s is required, please check api usage');
        } else {
            options.params.cryptKeyId = params.cryptKeyId;
            options.params.macKeyId = params.macKeyId;
        }
    } else {
        options.params.keyId = params.keyId;
    }
    if (params.hasOwnProperty('isPKCS7')) {
        // Need isPKCS7 property to exist only for operations that needs it else ignore
        options.params.isPKCS7 = typeof params.isPKCS7 === 'boolean' ? params.isPKCS7 : false;
    }
    if (params.signedData) {
        // Need signedData property to exist only for operations that need it else ignore
        options.params.signedData = params.signedData;
    }
    options.params.encodedData = params.encodedData;

    // The below param is needed to be passed to agent for getting external sslCtx
    if (params.internal_external) {
        // operations related to SSL Inbound and OutboundConfig
        options.params.internal_external = params.internal_external;
    }

    return options;
}

function KeyMakerClient(options) {
    var vaultSecretKeys, vaultAlgos,
        vaultKeyStore;

    debug('Constructing keyMakerClient');
    options = options || {};
    // By Default isAgentEnabled is TRUE.
    // We set it to FALSE if passed in the options object
    if('isAgentEnabled' in options && options.isAgentEnabled === false) {
        isAgentEnabled = false;
    }
    if(isAgentEnabled) pool = new ConnectionPool(options);
    else {
        console.log('keymaker bootstrapping, Agent Disabled Mode');
        utils.writeCalEvent('create', 'Agent Disabled Mode', {});
    }
    // set ConnectionPoolConfig object for cryptoserv
    utils.setCsPoolConfig(csUtils.getCryptoservConnPoolConfig(options));

    moduleConfig.version = options.version || 1;
    moduleConfig.appname = options.appname || appName;
    moduleConfig.secret = options.secret;
    assert(moduleConfig.secret, 'secret is required');
    assert(moduleConfig.appname, 'appname is required');
    // set the vault cache (keys and algo info from protected config) in memory
    vaultSecretKeys = options.secretKeys;
    vaultAlgos = options.algos;
    if (vaultSecretKeys) {
        for (var key in vaultSecretKeys) {
            keyStore.vaultKeyCache.set(key, base64.decode(vaultSecretKeys[key]));
        }
    }
    if (vaultAlgos) {
        for (var algoKey in vaultAlgos) {
            keyStore.vaultAlgoCache.set(algoKey, vaultAlgos[algoKey]);
        }
    }
    // set the vault cache (asymmetric keys and keystore) entries in memory
    vaultKeyStore = options.credentials;
    if (Object.keys(vaultKeyStore).length === 0) return;

    if (vaultKeyStore.hasOwnProperty('passphrase')) {
        keyStore.vaultKeyStoreRegistry.set('passphrase', vaultKeyStore.passphrase);
    }

    if (vaultKeyStore.hasOwnProperty('ca')) {
        keyStore.vaultKeyStoreRegistry.set('trustedServers', vaultKeyStore.ca);
    }

    if (vaultKeyStore.hasOwnProperty('cert')) {
        keyStore.vaultKeyStoreRegistry.set('certs', vaultKeyStore.cert);
    }

    if (vaultKeyStore.hasOwnProperty('key')) {
        keyStore.vaultKeyStoreRegistry.set('key', vaultKeyStore.key);
    }
    keyStore.vaultKeyStorePopulated();
}

function makeCsCall(operation, keyId, data, callback){
    if(cryptoservPool === undefined) cryptoservPool = new ConnectionPool(utils.getCsPoolConfig());
    getAppCtx("cryptoserv", function(appContext) {
        utils.setAppContext(appContext);
        return csUtils.callCryptoserv(cryptoservPool, moduleConfig.appname, operation, keyId, data, callback);
    });
}

function getAppCtx(servername, callback) {
    getClient().getAC(servername, function(err, appContext){
        if (err) {
            debug('Error in getAppCtx: ' + err);
            appContext = APP_CTX_NA;
        }
        return callback(appContext);
    });
}

function nsParse(data) {
    var result;
    try {
        result = JSON.parse(NetString.read(data));
    } catch (e) {
        result = {
            error: e
        };
    }
    return result;
}

function makeCall(operation, params, localCryptoException, callback) {
    var calTxn, detail, initTimeOut, calOperationName;

    var nsWriter = NetString.writeStream();
    var correlationId = utils.getCorrelationId();
    var options = buildOptions(operation, correlationId, params);

    if (params.hasOwnProperty('calOpName')) {
        calOperationName = params.calOpName;
    } else calOperationName = operation;

    assert.ok(options.params, 'KeyMakerClient-makeCall: params is mandatory.');
    // set detail based on keyId
    if (options.params.keyId) detail = options.params.keyId;
    else if (options.params.cryptKeyId) detail = options.params.cryptKeyId;
    // set initTimeOut and create Cal transaction both based on operation
    // get_exportable_keys handled specially, it has large initTimeOut value to fetch keys from agent at startup
    if (operation === 'get_exportable_keys') {
        if (params.initTimeOut && typeof params.initTimeOut === 'number') initTimeOut = params.initTimeOut;
        detail = 'get_exportable_keys';
        calTxn = utils.createCalTransaction('keymakerclient_getkeys', detail);
    } else {
        calTxn = utils.createCalTransaction(CAL_KEYMAKER_TRANSACTION + calOperationName, detail);
        var logData = 'Falling Back on Agent ';
        if (operation === 'sign' || operation === 'verify') logData = operation + ' operation Supported only By Agent ';
        utils.writeCalEvent(calOperationName, detail, logData + localCryptoException);
    }
    // We expect detail either to be get_exportable_keys OR keyId/cryptKeyId and macKeyId
    if (!detail) throw new Error('KeyMakerClient-makeCall: keyId / cryptKeyId AND macKeyId is mandatory.');

    // To differentiate between the type of input data
    // If by any chance 'isArray' propert is not set
    // we default it to undefined
    if (!params.hasOwnProperty('isArray')) {
        params.isArray = 'undefined';
    }

    var chunk = "",
        chunkLen = 0,
        netstringSize,
        attempts = 0,
        readBufferSize,
        error;

    pool.acquire(function(err, client) {
        if (err) {
            utils.writeCalEvent(calOperationName, detail, {
                error: err
            }, 'ERROR');
            if (calTxn) calTxn.complete();
            return callback(err, null);
        }
        if (initTimeOut) client.setTimeout(initTimeOut);
        client.on('timeout', onTimeout);
        client.on('error', onError);
        client.on('data', onReceive);
        client.on('close', onClose);
        nsWriter.pipe(client);
        nsWriter.write(JSON.stringify(options));

        function onReceive(data) {
            var responseCode,
                responseDataSize,
                nsResponse;
            if (!data) {
                error = new Error('Empty response From KeyMakerAgent');
                utils.writeCalEvent(calOperationName, detail, {
                    error: error
                }, 'ERROR');
                if (calTxn) calTxn.complete();
                return callback(error, null);
            }
            chunk += data;
            chunkLen += data.length;
            if (!readBufferSize && /:/.test(chunk)) {
                readBufferSize = utils.getNetStringLength(chunk);
                netstringSize = String(readBufferSize).length + 1;
            }
            if (!readBufferSize) return;
            responseDataSize = chunkLen - netstringSize;
            if (responseDataSize !== (readBufferSize + 1)) attempts++;
            else {
                // Now that we have the complete response, releasing socket back to pool
                // Before we release socket back to pool unbinding registered data listeners
                client.removeListener('data', onReceive);
                client.removeListener('timeout', onTimeout);
                client.removeListener('error', onError);
                client.removeListener('close', onClose);
                nsWriter.unpipe(client);
                if (operation === 'get_exportable_keys') {
                    //earlier was set to initTimeOut, re-setting back to socketReadTimeOut value
                    var socketTimeout = utils.getTimeOut();
                    client.setTimeout(socketTimeout);
                }
                pool.release(client);
                nsResponse = nsParse(chunk);
                responseCode = nsResponse && nsResponse.response_code;
                if (responseCode !== 200) error = nsResponse.error;
                else {
                    if(params.isArray !== undefined) {
                        if(!params.isArray) processAgentResponse_toSingleOutput(nsResponse, operation);
                        else processAgentResponse_toMultiOutput(nsResponse, operation);
                    }
                }
                if (calTxn) {
                    if (error) {
                        utils.writeCalEvent(calOperationName, detail, {
                            resCode: responseCode,
                            error: error
                        }, 'ERROR');
                    } else {
                        utils.writeCalEvent(calOperationName, detail, {
                            kmclient: 'Attempts to receive response chunks: ' + attempts
                        });
                        calTxn.status = utils.getCalStatus('success');
                    }
                    calTxn.complete();
                }
                return callback(error, nsResponse);
            }
        }

        function onTimeout() {
            client.removeAllListeners();
            pool.destroy(client);
            error = new Error('SLA Exceeded: Entire response not received from KeyMakerAgent within SLA');
            error.errno = 'ETIMEDOUT';
            utils.writeCalEvent(calOperationName, detail, {
                error: error
            }, 'WARNING');
            if (calTxn) calTxn.complete();
            return callback(error, null);
        }

        function onError(err) {
            client.removeAllListeners();
            utils.writeCalEvent('ERROR_EVENT_EMITTED', calOperationName, {
                error: err
            }, 'ERROR');
            if (calTxn) calTxn.complete();
            pool.destroy(client);
            return callback(err, null);
        }

        function onClose() {
            client.removeAllListeners();
            pool.destroy(client);
            error = new Error('Connection to keymakeragent closed unexpectedly');
            utils.writeCalEvent(calOperationName, detail, {
                error: error
            }, 'WARNING');
            if (calTxn) calTxn.complete();
            return callback(error, null);
        }

        function processAgentResponse_toSingleOutput(nsResponse, operation) {
            if ('result' in nsResponse === false) return;
            if ('encodedData' in nsResponse.result) {
                // The Agent API is such that it always responds back with a list for the encodedData
                // As this method is to process a list output from agent having a single member into
                // a string, we do the following.
                nsResponse.result.encodedData = nsResponse.result.encodedData.toString();
                if (operation === 'decrypt' || operation === 'unseal' || operation === 'nonkey') {
                    // We also set the plainData version to the response object
                    nsResponse.result.plainData = base64.decode(nsResponse.result.encodedData);
                }
            }
            if (operation === 'verify') {
                if ('signedData' in nsResponse.result) {
                    nsResponse.result.signedData = nsResponse.result.signedData.toString();
                }
                if ('isVerified' in nsResponse.result) {
                    var isVerified = nsResponse.result.isVerified.toString();
                    if (isVerified === 'true') nsResponse.result.isVerified = true;
                    else nsResponse.result.isVerified = false;
                }
            }
        }

        function processAgentResponse_toMultiOutput(nsResponse, operation) {
            if ('result' in nsResponse === false) return;
            if ('encodedData' in nsResponse.result) {
                if (operation === 'decrypt' || operation === 'unseal') {
                    nsResponse.result.plainData = [];
                    // We dont process anything wrt encodedData as encodedData is already a list that
                    // is returned from the agent
                    for (var i in nsResponse.result.encodedData) {
                        nsResponse.result.plainData[i] = base64.decode(nsResponse.result.encodedData[i]);
                    }
                }
            }
        }
    });
}

function getKeysFromAgent(timeOut, callback) {
    var params = {};
    if (timeOut) params.initTimeOut = timeOut;
    return makeCall('get_exportable_keys', params, '', callback);
}

function processKeyData(keySet) {
    if (!keySet || Object.keys(keySet).length === 0) throw new Error('KeyMakerClient-processKeyData-EmptyInputException- no keys to process');

    var keyAlgoVersions = new Dict();
    // We get the keystore registry and then start processing to set the keystore data.
    // The keystore data would be set across multiple methods below.
    var keymakerKeyStore = keyStore.keyMakerKeyStoreProps;
    // Like the above, we are getting the ssoKeyStore registry to set the SSOConfig data.
    var ssoKeyStore = keyStore.ssoKeyStoreKeyMakerProps;

    for (var keyType in keySet) {
        if (keyType === 'secretkeys') {
            processSecretKeys(keyType, keySet.secretkeys, keyAlgoVersions);
        } else if (keyType === 'nonkeys') {
            processSecretKeys(keyType, keySet.nonkeys, keyAlgoVersions);
        } else if (keyType === 'keystores') {
            processKeyStores(keySet.keystores, keymakerKeyStore, ssoKeyStore);
        } else if (keyType === 'keypairs') {
            setInKeyStore(keymakerKeyStore, keySet.keypairs);
        } else if(keyType === 'certificates') {
            setInKeyStore(keymakerKeyStore, keySet.certificates);
        }
    }

    // Process the consolidated Trust Store - This supports the legacy external/internal
    // connections use-case provided by the processConsolidatedTrustStore api.
    processConsolidatedTrustStore(keymakerKeyStore);

    // Key Data has been processed successfully and we are going to add into keymakercache
    if (keyAlgoVersions.length <= 0) {
        debug('Unexpected: keyAlgoVersions is less than or eq to 0');
        // ::ToDo:: Need to verify if CAL log is required.
        return;
    }
    var GCMKeyVersions = new Dict();
    var entry = keyAlgoVersions.entries();
    for (var i = 0; i < entry.length; i++) {
        var keyName = entry[i][0];
        var valueObject = entry[i][1];
        var subKeyName = utils.createSubKey(keyName);
        // set key value
        keyStore.kmKeyCache.set(keyName, base64.decode(valueObject.value));
        // set version and algo
        if (valueObject.version && valueObject.algo && /GCM/.test(valueObject.algo)) {
            var ver = Number(valueObject.version);
            if (GCMKeyVersions.has(subKeyName)) {
                if (GCMKeyVersions.get(subKeyName) < ver) {
                    keyStore.kmalgoCache.set(subKeyName + '_version', String(ver));
                    GCMKeyVersions.set(subKeyName, ver);
                }
            } else {
                keyStore.kmalgoCache.set(subKeyName + '_version', String(ver));
                keyStore.kmalgoCache.set(subKeyName + '_algo', valueObject.algo);
                if (valueObject.type) {
                    keyStore.kmalgoCache.set(subKeyName + '_type', valueObject.type);
                }
            }
            keyStore.kmalgoCache.set(keyName.replace(/_[0-9]+$/g, ''), 'cached');
        } else {
            if (valueObject.algo) {
                keyStore.kmalgoCache.set(subKeyName + '_algo', valueObject.algo);
            }
            if (valueObject.version) {
                keyStore.kmalgoCache.set(subKeyName + '_version', valueObject.version);
            }
            if (valueObject.type) {
                keyStore.kmalgoCache.set(subKeyName + '_type', valueObject.type);
            }
        }
        //Application Context
        if(keyName.endsWith("_app_context")) {
            var appContextValue = base64.decode(valueObject.value).toString();
            var appContext = JSON.parse(base64.decode(appContextValue.split('.')[1]));
            keyStore.kmKeyCache.set(keyName + "_exp", appContext.exp.toString());
        }
    }
    keyStore.debugCache();
}

function processSecretKeys(type, secretKeyArr, keyAlgoVersions) {
    assert.ok(secretKeyArr, 'KeyMakerClient-processSecretKeys-EmptyInputException-  secretKeyArr cannot be null.');
    for (var i = 0; i < secretKeyArr.length; i++) {
        var next = secretKeyArr[i],
            object = (type === 'nonkeys') ? next.nonkey : next.secretkey,
            valueObject = {};
        if (!object) continue;
        var keyName = object.name;
        valueObject.value = (type === 'nonkeys') ? object.encoded_key_data : object.encoded_secret_key;
        valueObject.type = (type === 'nonkeys') ? 'nonkey' : 'secretkey';
        var pattern = object.attributes;
        var matched;
        try {
            matched = pattern.match(/traits=([a-zA-Z0-9_]+)&?/i);
        } catch (e) {
            utils.writeCalEvent('processSecretKeys', 'ErrorInInputFromAgent', 'Unable to match algorithm name from input data-' + pattern + '-stacktrace-' + e, 'WARNING');
        }
        if (matched) valueObject.algo = matched[1].toString();
        else valueObject.algo = object.algorithm; //mackeys gets algo information not as traits
        var version;
        if (object.version) {
            version = Number(object.version);
        }
        if (!version) keyAlgoVersions.set(keyName, valueObject);
        else {
            if (valueObject.algo && /GCM/.test(valueObject.algo)) {
                keyName += '_' + utils.formatVersion(version);
                valueObject.version = utils.formatVersion(version);
                keyAlgoVersions.set(keyName, valueObject);
            } else {
                if (keyAlgoVersions.has(keyName)) {
                    valueObject = keyAlgoVersions.get(keyName);
                    //For non-GCM keys set only if the version is latest
                    if (version > valueObject.version) { // check if version is number
                        //log warning telling multiple versions are found for non GCM key
                        valueObject.version = version;
                        valueObject.value = (type === 'nonkeys') ? object.encoded_key_data : object.encoded_secret_key;
                        keyAlgoVersions.set(keyName, valueObject);
                    }
                } else {
                    valueObject.version = version;
                    keyAlgoVersions.set(keyName, valueObject);
                }
            }
        }
    }
}

// This method processes the certificates that come as part of a specific merchant's keystore
// from the keymakeragent and inserts into the cache of merchant specific keystore.
function processCertificates(trustStore, certificate, certificateType) {
    try {
        var issueWithValidation = validateCertificates(certificate);
        if (issueWithValidation) {
            console.error(issueWithValidation.msg);
            utils.writeCalEvent('KM_CERT_PROCESSING_ERROR', 'processCertificates', {
                error: issueWithValidation.obj,
            }, 'ERROR');
            return;
        }
        var certName = certificate.name;
        var certsArr = certificate.encoded_certificates;
        var certsLen = certsArr.length;

        for (var i = 0; i < certsLen; i++) {
            var decryptedCert = base64.decode(certsArr[i]);
            if(certificateType === 'special') { // special certificateType is for certificates in external or sso keystores
                trustStore.push(decryptedCert);
            } else if (certificateType === 'general') { // general certificateType is for individual certificates
                keyMakerprops.setProperty(certName + '_max_version', certificate.version);
                certName = certName + '_' + certificate.version;
                trustStore[certName] = {};
                trustStore[certName].publicCerts = [];
                trustStore[certName].publicCerts.push(decryptedCert);
            } else {
                throw new Error('KeyMakerClient-processCertificates- certificateType can only be general or special');
            }
        }
    } catch (e) {
        console.error('KeyMakerClient-processCertificates-ErrorCaught-', e);
    }
}

// This method sets independent asymmetric keys into the keyStores Data Structure
// under the keyname 'keymaker.nks'
function setInKeyStore(keyStores, keypairArr) {
    try {
        if (!keypairArr) {
            console.error('KeyMakerClient-setInKeyStore: keypairArr object is empty.');
            return;
        }
        var keypairLen = keypairArr.length;
        if (keypairLen === 0) {
            console.error('KeyMakerClient-setInKeyStore: Unable to load keys from agent. Empty keypair values.');
            return;
        }
        // We dont support asymmetric encrypt/decrypt, just adding the keys to the cache with a 'nosupport' flag
        // when we lookup for an asymmetric key during local encrypt, we fallback on the agent with the correct
        // reason that says we dont support asymmetric operations in localCrypto rather than failing with a 'no-keyIn-Cache'
        // error. As part of this we prepend a string to the keyName to distinguish asymmetric from symmetric keys.
        for (var i = 0; i < keypairArr.length; i++) {
            if (!keypairArr[i].keypair) continue;
            var keyName = keypairArr[i].keypair.name;
            keyName = keyName + '_asymmetric_key';
            keyStore.kmKeyCache.set(keyName, 'nosupport');
        }
        // Here on, we work on building the keystore.

        for (var arrLen = 0; arrLen < keypairArr.length; arrLen++) {
            var keypairList = keypairArr[arrLen];

            if (Object.keys(keypairList).length === 0) continue;

            if (keypairList.hasOwnProperty('keypair')) {
                processKeyPairs(ks, keypairList.keypair, 'general'); // general keypairType is for individual keypairs
            } else if (keypairList.hasOwnProperty('certificate')) {
                processCertificates(ks, keypairList.certificate, 'general'); // general certificateType is for individual certificates
            } else {
                var msg = 'keypair prop not found in the keypairsList';
                console.error(msg);
                utils.writeCalEvent('KM_KEYPAIR_PROCESSING_ERROR', 'setInKeyStore', {
                    error: msg,
                }, 'ERROR');
            }
        }
        // .nks meaning NodeKeyStore
        keyStores.set('individual_keypairs_certificates_keymaker.nks', ks);
    } catch (e) {
        console.error('KeyMakerClient-setInKeyStore-ErrorCaught-', e);
    }
}

// This method processes the independent asymmetric keys and inserts
//  the private key and public certList into a javascript object.
function processKeyPairs(keystore, keyPairElem, keypairType) {
    try {
        // validation of agent response to see if its fit to process the keypairs.
        var issueWithValidation = validateKeyPairs(keyPairElem);
        if (issueWithValidation) {
            console.error(issueWithValidation.msg);
            utils.writeCalEvent('KM_KEYPAIR_PROCESSING_ERROR', 'processKeyPairs', {
                error: issueWithValidation.obj,
            }, 'ERROR');
            return;
        }
        var keyName = keyPairElem.name;

        // localCryptoApi doesn't support asymmetric keys, just adding the keys to the cache so that
        // when we lookup for the key during encrypt operation, we fallback on the agent and log
        // the correct reason. We prepend a string to distinguish asymmetric from symmetric keys
        var asymKeyName = keyName + '_asymmetric_key';
        keyStore.kmKeyCache.set(asymKeyName, 'nosupport');

        var privateKey = keyPairElem.private_key.encoded_private_key;
        if (!privateKey) throw new Error('KeyMakerClient-processKeyPairs-EmptyInputException-  encoded_private_key cannot be null.');
        var privateKeyBuffer = base64.decode(privateKey);

        var certArr = keyPairElem.certificates;
        var certBufferList = [];
        for (var len = 0; len < certArr.length; len++) {
            var cert = certArr[len].encoded_cert;
            if (!cert) throw new Error('KeyMakerClient-processKeyPairs-EmptyInputException-  encoded_cert cannot be null.');
            var certBuffer = base64.decode(cert);
            certBufferList.push(certBuffer);
        }

        // set the keystore with the private key that belongs to PayPal.
        // set the keystore with the public certs that may be required for client-auth
        // special keypairType is for keypairs in external or sso keystores
        if (keypairType === 'special') {
            keystore.privateKey = privateKeyBuffer;
            keystore.publicCerts = certBufferList;
        } else if (keypairType === 'general') { // general keypairType is for individual keypairs
            keyMakerprops.setProperty(keyName + '_max_version', keyPairElem.version);
            keyName = keyName + '_' + keyPairElem.version;
            keystore[keyName] = {};
            keystore[keyName].privateKey = privateKeyBuffer;
            keystore[keyName].publicCerts = certBufferList;
        } else {
            throw new Error('KeyMakerClient-processKeyPairs- keypairType can only be general or special');
        }
    } catch(e) {
        console.error('KeyMakerClient-processKeyPairs-ExceptionCaught-', e);
        utils.writeCalEvent('KM_KEYPAIR_PROCESSING_ERROR', 'processKeyPairs', {
            error: e,
        }, 'ERROR');
    }
}
// The method ensures creation of the keystore data structure that will contain
// both merchant specific keystores and independent keypairs under a keymaker.nks keystore
function processKeyStores(keyStoreArr, extKeyStores, ssoKeyStore) {
    // Input Validation
    if (!keyStoreArr) {
        console.error('KeyMakerClient-processKeyStores: keyStoreArr is empty.');
        return;
    }
    try {
        for (var i = 0; i < keyStoreArr.length; i++) {
            var tempKeyStore = keyStoreArr[i].keystore;
            var issueWithValidation = validateKeyStores(tempKeyStore);
            if (issueWithValidation) {
                console.error(issueWithValidation.msg);
                utils.writeCalEvent('KM_KEYSTORE_PROCESSING_ERROR', 'processKeyStores', {
                    error: issueWithValidation.obj,
                }, 'ERROR');
                continue;
            }

            var newKeyStoreName = tempKeyStore.name + '_keymaker';
            var entries = tempKeyStore.entries;
            // attributes get validated within validateKeyStores method
            var attb = tempKeyStore.attributes;
            var ks = {};
            // Create properties that would be filled up later
            ks.protocolVer;
            ks.cipherSuites;
            ks.trustedCerts = [];

            if (tempKeyStore.hasOwnProperty('ssl_config')) {
                if (tempKeyStore.ssl_config.hasOwnProperty('preffered_protocol')) {
                    ks.protocolVer = tempKeyStore.ssl_config.preffered_protocol;
                }

                if (tempKeyStore.ssl_config.hasOwnProperty('preffered_cipher_suites')) {
                    var cipherSuitesString = tempKeyStore.ssl_config.preffered_cipher_suites;
                    ks.cipherSuites = cipherSuitesString ? cipherSuitesString.split(',') : undefined;
                }
            }

            for (var j = 0; j < entries.length; j++) {
                if(!entries[j].hasOwnProperty('entry')) continue;
                if(!entries[j].hasOwnProperty('entry_type')) continue;

                var certObj = entries[j].entry;
                if (Object.keys(certObj).length === 0) continue;

                if((/keystoretype=external/i.test(attb)) || (/keystoretype=sso/i.test(attb))) {
                    ks.publicCerts;
                    ks.privateKey;
                    if (certObj.hasOwnProperty('keypair')) {
                        processKeyPairs(ks, certObj.keypair, 'special'); // special keypairType is for keypairs in external or sso keystores
                    }
                    if (certObj.hasOwnProperty('certificate')) {
                        processCertificates(ks.trustedCerts, certObj.certificate, 'special'); // special certificateType is for certificates in external or sso keystores
                    }
                } else {
                    if (certObj.hasOwnProperty('keypair')) {
                        processKeyPairs(ks, certObj.keypair, 'general'); // for non sso or external keystores
                    }
                    if (certObj.hasOwnProperty('certificate')) {
                        processCertificates(ks, certObj.certificate, 'general'); // for non sso or external keystores
                    }
                }
            }

            if (/keystoretype=sso/i.test(attb)) {
                var ssoConfig = utils.getDefaultExternalSSLConfigResponseObj();
                keyStore.processKeyMakerSSOKeyStore(ks, ssoConfig);
                ssoKeyStore.set(newKeyStoreName + '.nks', ssoConfig);
            } else {
                extKeyStores.set(newKeyStoreName + '.nks', ks); // .nks meaning NodeKeyStore
            }
        }
    } catch(e) {
        console.error('KeyMakerClient-processKeyStores-ExceptionCaught-', e);
    }
}

function processConsolidatedTrustStore(kmKeyStore) {
    try {
        // The below consolidatedTrustStoreList and consolidatedTrustedServers is not consolidated yet,
        // it will be done below after retrieving the external connections data from the keymaker
        // keystore. Before that, it will just have a copy of the vault keystore itself.
        var consolidatedKeyStore = keyStore.consolidatedTrustStoreRegistry;
        var consolidatedTrustStoreList = consolidatedKeyStore.get('trustedCerts');

        var externalKeyStoresFromKeyMaker = kmKeyStore.keys();
        var numOfExternalKeyStoresFromKeyMaker = kmKeyStore.keys().length;

        for (var i = 0; i < numOfExternalKeyStoresFromKeyMaker; i++) {
            // Get the CA details from the keymaker keystore
            var obj = kmKeyStore.get(externalKeyStoresFromKeyMaker[i]);
            if (!obj) continue; // we return back the vault trusted certs itself in this case.
            if (!obj.hasOwnProperty('trustedCerts')) continue;

            // We skip adding the obj.trustedCerts in to consolidatedTrustStore if privateKey
            // is found in the keystore. We would not consider this keystore eligible for consolidation.
            if (obj.hasOwnProperty('privateKey') && obj.privateKey) continue;

            var trustStore = obj.trustedCerts;
            if (!trustStore) continue;

            for (var j = 0; j < trustStore.length; j++) {
                var formattedCert = utils.convertToPEMFormat(trustStore[j], j);
                if (formattedCert) {
                    consolidatedTrustStoreList.push(formattedCert);
                } else {
                    console.error('processConsolidatedTrustStore-Consolidation was not done',
                                  'element=', i, 'length Of TrustStore=', numOfExternalKeyStoresFromKeyMaker);
                }
            }
        }
        consolidatedKeyStore.set('trustedCerts', consolidatedTrustStoreList);
    } catch (e) {
        console.error('keyMakerClient-processConsolidatedTrustStore-Processing Failed', e);
    }
}

function validateCertificates(certificate) {
    var err = {};
    var ERR_TYPE = 'Critical Error-';

    debug('certificate Being Validated is ', certificate);

    if (!certificate.hasOwnProperty('name')) {
        err.msg = ERR_TYPE + 'Agent Response Incomplete as \'name\' property not found-entry obj is ' + certificate;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!certificate.hasOwnProperty('encoded_certificates')) {
        err.msg = ERR_TYPE + 'Agent Response Incomplete as \'encoded_certificates\' property not found-entry obj is ' + certificate;
        err.obj = new Error(err.msg);
        return err;
    }

    var certsArr = certificate.encoded_certificates;
    var certsLen = certsArr.length;

    if (certsLen === 0) {
        err.msg = 'Unable to load certs from agent. Empty cert values.';
        err.obj = new Error(err.msg);
        return err;
    }
    //return undefined if no error
    return undefined;
}

function validateKeyPairs(keyPairElem) {
    var err = {};
    var msg_part1 = 'Critical Error-Agent Response Incomplete as ';
    var msg_part2 = ' property not found-KeyPairObject is ';
    var msg_part3 = ' property\'s value is empty-KeyPairObject is ';

    debug('keyPair Being Validated is ', keyPairElem);

    if (!keyPairElem) {
        err.msg = msg_part1 + 'object is empty ' + keyPairElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyPairElem.hasOwnProperty('name')) {
        err.msg = msg_part1 + ' \'name\'' + msg_part2 + keyPairElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyPairElem.hasOwnProperty('private_key')) {
        err.msg = msg_part1 + '\'private_key\'' + msg_part2 + keyPairElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyPairElem.private_key.hasOwnProperty('encoded_private_key')) {
        err.msg = msg_part1 + '\'encoded_private_key\'' + msg_part2 + keyPairElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (keyPairElem.private_key.encoded_private_key.length === 0) {
        err.msg = msg_part1 + '\'encoded_private_key\'' + msg_part2 + keyPairElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyPairElem.private_key.hasOwnProperty('algorithm')) {
        err.msg = msg_part1 + '\'algorithm name\'' + msg_part2 + keyPairElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyPairElem.hasOwnProperty('certificates')) {
        err.msg = msg_part1 + '\'certificates\'' + msg_part2 + keyPairElem;
        err.obj = new Error(err.msg);
        return err;
    }

    var certArr = keyPairElem.certificates;
    // Check if all certs have the encoded_cert property
    for (var i=0; i < certArr.length; i++) {
        if (!certArr[i].hasOwnProperty('encoded_cert')) {
            err.msg = msg_part1 + '\'encoded_cert\'' + msg_part3 + certArr[i];
            err.obj = new Error(err.msg);
            return err;
        }

        if (certArr[i].encoded_cert.length === 0) {
            err.msg = msg_part1 + '\'encoded_cert\'' + msg_part3 + certArr[i];
            err.obj = new Error(err.msg);
            return err;
        }
    }
    //return undefined if no error
    return undefined;
}

function validateKeyStores(keyStoreElem) {
    var err = {};
    var ERR_TYPE = 'Critical Error-';
    var atLeastOneEntryPropFound = false;
    var atLeastOneEntryFound = false;

    debug('keyStore Being Validated is ', keyStoreElem);

    if (!keyStoreElem.hasOwnProperty('name')) {
        err.msg = ERR_TYPE + 'Agent Response Incomplete as \'name\' property not found- Obj under validation is ' + keyStoreElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyStoreElem.hasOwnProperty('attributes')) {
        err.msg = ERR_TYPE + 'Agent Response Incomplete as \'attributes\' property not found- Obj under validation is ' + keyStoreElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyStoreElem.attributes) {
        console.error('UnExpected_Input_From_KMAgent :Error In processKeyStores attributes property has no value');
        err.msg = ERR_TYPE + 'Agent Response with \'attributes\' value is undefined or null- Obj under validation is ' + keyStoreElem;
        err.obj = new Error(err.msg);
        return err;
    }

    if (!keyStoreElem.hasOwnProperty('entries')) {
        err.msg = ERR_TYPE + 'Agent Response Incomplete as \'entries\' property not found- Obj under validation is ' + keyStoreElem;
        err.obj = new Error(err.msg);
        return err;
    }
    // Check if all entries have the entry property and its value
    var entries = keyStoreElem.entries;
    for (var i = 0; i < entries.length; i++) {
        if (entries[i].hasOwnProperty('entry')) {
            atLeastOneEntryPropFound = true;
            if (Object.keys(entries[i].entry).length !== 0) atLeastOneEntryFound = true;
        }
    }

    if (!atLeastOneEntryPropFound) {
        err.msg = 'WARNING-' + 'Agent Response Incomplete as there is not a single valid \'entry\' property';
        err.obj = new Error(err.msg);
        return err;
    }
    if (!atLeastOneEntryFound) {
        err.msg = 'WARNING-' + 'Agent Response Incomplete as there is not a single valid \'entry\' property with value';
        err.obj = new Error(err.msg);
        return err;
    }
    return undefined;
}

function processAgentResponse_sslConfigOutBound(agentResponse, keystoreName) {
    var processedData = {};
    processedData.error;
    processedData.res;
    var calTxn = utils.createCalTransaction('sslconfig_outbound', 'processAgentResponse');

    try {
        if (!agentResponse) throw new Error('agentResponse cant be empty');
        if (!agentResponse.hasOwnProperty('result')) throw new Error('agentResponse \'result\' property is mandatory');
        if (!agentResponse.hasOwnProperty('server_info')) throw new Error('agentResponse \'server_info\' property is required');
        if (!agentResponse.result.hasOwnProperty('trustedCerts')) throw new Error('agentResponse.result \'trustedCerts\' property is mandatory');
        var externalSSLConfig = utils.getDefaultExternalSSLConfigResponseObj(agentResponse.server_info);

        var trustedCertsList_NonPEM = agentResponse.result.trustedCerts;

        if (!trustedCertsList_NonPEM ||  Object.keys(trustedCertsList_NonPEM).length === 0) {
            throw new Error('undesirable to have trustedCerts empty');
        }
        var trustedCertsList_PEM = [];

        for (var i = 0; i < trustedCertsList_NonPEM.length; i++) {
            var formattedCert = utils.convertToPEMFormat(trustedCertsList_NonPEM[i], i);
            trustedCertsList_PEM.push(formattedCert);
        }
        externalSSLConfig.result.trustedCerts = trustedCertsList_PEM;

        if (agentResponse.result.hasOwnProperty('protocolVer')) {
            externalSSLConfig.result.protocolVer = agentResponse.result.protocolVer;
            if (!externalSSLConfig.result.protocolVer) {
                throw new Error('undesirable to have protocolVer empty');
            }
        } else externalSSLConfig.result.protocolVer = undefined;

        if (agentResponse.result.hasOwnProperty('cipherSuites')) {
            externalSSLConfig.result.cipherSuites = agentResponse.result.cipherSuites;
            if (!externalSSLConfig.result.cipherSuites) {
                throw new Error('undesirable to have cipherSuites empty');
            }
        } else externalSSLConfig.result.cipherSuites = undefined;

        // Processing private Key
        if (agentResponse.result.hasOwnProperty('privateKey')) {
            var privateKey = agentResponse.result.privateKey;
            if (!privateKey) {
                // can be empty
                if (calTxn) calTxn.addData('privateKey', 'notFound');
                externalSSLConfig.result.privateKey = undefined;
            } else {
                if (privateKey.constructor === Array) {
                    throw new Error('privateKey cannot be a list, should be single');
                }
                var formattedKey = utils.convertToPEMFormat(privateKey);
                externalSSLConfig.result.privateKey = formattedKey;
            }
        } else externalSSLConfig.result.privateKey = undefined;

        // Processing public certs
        if (agentResponse.result.hasOwnProperty('publicCerts')) {
            var publicCertsList_NonPEM = agentResponse.result.publicCerts;
            if (!publicCertsList_NonPEM ||  Object.keys(publicCertsList_NonPEM).length === 0) {
                // Not Mandatory. can be empty
                if (calTxn) calTxn.addData('publicCerts', 'notFound');
                externalSSLConfig.result.publicCerts = undefined;
            } else {
                var publicCertsList_PEM = [];
                for (var j = 0; j < publicCertsList_NonPEM.length; j++) {
                    var formattedPublicCert = utils.convertToPEMFormat(publicCertsList_NonPEM[j], j);
                    publicCertsList_PEM.push(formattedPublicCert);
                }
                externalSSLConfig.result.publicCerts = publicCertsList_PEM;
            }
        } else externalSSLConfig.result.publicCerts = undefined;

        processedData.res = externalSSLConfig;
        return processedData;
    } catch (e) {
        processedData.error = 'KeyMakerClient-processAgentResponse_sslConfigOutBound-ExceptionCaught-' + e;
        utils.writeCalEvent('sslconfig_outbound_agentRes_processor', keystoreName, {
            error: processedData.error
        }, 'ERROR');
        return processedData;
    }
}

function processVaultResponse_sslConfigOutBound() {
    var processedData = {};
    processedData.error;
    processedData.res;

    try {
        var externalSSLConfig = utils.getDefaultExternalSSLConfigResponseObj('LegacyVaultCache');
        externalSSLConfig.result.trustedCerts = keyStore.vaultKeyStoreRegistry.get('trustedServers');
        externalSSLConfig.result.publicCerts = keyStore.vaultKeyStoreRegistry.get('certs');
        externalSSLConfig.result.privateKey = keyStore.vaultKeyStoreRegistry.get('key');

        processedData.res = externalSSLConfig;
        return processedData;
    } catch (e) {
        processedData.error = 'KeyMakerClient-processVaultResponse_sslConfigOutBound-ExceptionCaught-' + e;
        utils.writeCalEvent('sslconfig_outbound_vaultkeyStore_processor', 'vaultOnly', {
            error: processedData.error
        }, 'ERROR');
        return processedData;
    }
}

// get highest version of the key from keystore
function getKeyfromKeystore(keyname) {
    var keyStoreNames = (keyStore.keyMakerKeyStoreProps).keys(),
        maxVersion = keyMakerprops.getMaxVersion(keyname),
        key = '';

    if (maxVersion && maxVersion !== undefined && maxVersion > 0) {
        keyname = keyname + '_' + maxVersion;
    }
    for(var i = 0; i < keyStoreNames.length; i++) {
        var indKeyStore = keyStore.getKMKeyStoreCache(keyStoreNames[i].slice(0, -4));  //slice last 4 characters '.nks'
        if(!indKeyStore.hasOwnProperty(keyname)) continue;

        key = indKeyStore[keyname];
        break;
    }
    return key;
}

// get all versions of the key.
// if maxVersion is not found, it means the key may be available in protected package
function getKeyfromKeystoreAll(keyname) {
    var keyStoreNames = (keyStore.keyMakerKeyStoreProps).keys(),
        maxVersion = keyMakerprops.getMaxVersion(keyname),
        indKeyStore,
        key = {};

    if (maxVersion && maxVersion !== undefined && maxVersion > 0) {
        for(var i = 1; i <= maxVersion; i++) {
            var keyId = keyname + '_' + i;
            for(var j = 0; j < keyStoreNames.length; j++) {
                indKeyStore = keyStore.getKMKeyStoreCache(keyStoreNames[j].slice(0, -4));  //slice last 4 characters '.nks'
                if(!indKeyStore.hasOwnProperty(keyId)) continue;

                key[i] = {};
                key[i] = indKeyStore[keyId]; // key is obtained from KeyMaker, and all versions of the key are returned, as "version: key_value" pair
                break;
            }
        }
    } else {
        for (var k = 0; k < keyStoreNames.length; k++) {
            indKeyStore = keyStore.getKMKeyStoreCache(keyStoreNames[k].slice(0, -4));  //slice last 4 characters '.nks'
            if (!indKeyStore.hasOwnProperty(keyname)) continue;

            key['0'] = {};
            key['0'] = indKeyStore[keyname]; // key obtained from protected package, and returned as 0: key_value
            break;
        }
    }
    return key;
}


function getPrivateKey(params, callback) {
    var maxVersion = keyMakerprops.getMaxVersion(params.keyId),
        keyname = params.keyId,
        hash = '';
    if (params.thumbprintHash === 'x5t') {
        hash = 'sha1';
    } else if (params.thumbprintHash === 'x5t#S256') {
        hash = 'sha256'
    }
    var protectedHeader = JSON.parse(jose.util.base64url.decode(params.input.protected));
    var thumbprintHeader = protectedHeader[params.thumbprintHash];
    var keys = getKeyfromKeystoreAll(keyname);

    if (thumbprintHeader) { // if header has a thumbprint, obtain private key for public key with same thumbprint
        Object.keys(keys).forEach(function(key) {
            var pubKeyPEM = utils.convertToPEMFormat(new Buffer(keys[key].publicCerts[0], 'base64'), 1);

            pem.getFingerprint(pubKeyPEM.toString('ascii'), hash, function (err, res) {
                if (err)
                    return callback(new Error('KeyMaker-getPrivateKey- error while creating thumbprint - ', err), null);

                var thumbprint = (res && res.fingerprint || '').toString();
                if (thumbprint === thumbprintHeader) {
                    var privKeyDer = keys[key].privateKey;
                    var privKeyJWK = utils.derToJwk(privKeyDer);
                    return callback(null, privKeyJWK);
                } else if (key == maxVersion) {
                    return callback(new Error('KeyMaker-getPrivateKey- thumbprint provided but it did not match'), null);
                }
            });
        });
    } else if (!thumbprintHeader) { // if thumbprint is not provided, return all versions of the key, and decrypt using all versions until successful decryption
        return callback(null, keys);
    }
}

// operation logic for JWE Decryption
function createJweDecrypt(key, input, callback) {
    var privKeyJWK;
    if(key.hasOwnProperty('p')) {
        privKeyJWK = key;
    } else {
        var privKeyDer = key.privateKey;
        privKeyJWK = utils.derToJwk(privKeyDer);
    }
    jose.JWK.asKey(privKeyJWK, 'JSON').then(function (result) {
        jose.JWE.createDecrypt(result).decrypt(input).then(function (result) {
            callback(null, result);
        }).catch(function (error) {
            callback(new Error('KeyMaker-createJweDecrypt- error in decrypt- ' + error), null);
        });
    }).catch(function (err) {
        callback(new Error('KeyMaker-createJweDecrypt- error in JWK.asKey', err), null);
    });
}

// operation logic for JWS Verify
function createJwsVerify(key, input, callback) {
    var pubKeyPEM = utils.convertToPEMFormat(new Buffer(key.publicCerts[0], 'base64'), 1);
    pem.getPublicKey(pubKeyPEM.toString('ascii'), function (error, res) {
        if (error) {
            return callback(new Error('KeyMaker-createJwsVerify- unable to get public key from certificate. ' + error), null);
        }
        var pubKeyJWK = pem2jwk(res.publicKey);

        jose.JWK.asKey(pubKeyJWK, 'JSON').then(function (result) {
            jose.JWS.createVerify(result).verify(input).then(function (result) {
                return callback(null, result);
            }).catch(function (error) {
                return callback(new Error('KeyMaker-createJwsVerify- error in verify- ' + error), null);
            });
        }).catch(function (err) {
            return callback(new Error('KeyMaker-createJwsVerify- error in JWK.asKey- ' + err), null);
        });
    });
}

// iterate over multiple verions of the key asynchronously
function iterateOverVersions(key, input, opLogic, callback) {
    var index = Object.keys(key).length;  //keep track of the index of the next item to be processed

    function report(err, res) {
        index--;
        if(err) {
            if(index <= 0)
                return callback(err, null);
            opLogic(key[index], input, report);
        }
        if(res)
            return callback(null, res);
    }

    opLogic(key[index], input, report); // start with maximum version
}

KeyMakerClient.prototype.jweEncrypt = function (params, callback) {
    if (!params || !params.input || !params.keyId || !params.alg || !params.enc) {
        return callback(new Error('KeyMaker-jweEncrypt- parameters missing! input, keyId, alg, and enc are mandatory parameters'), null);
    }
    var key = getKeyfromKeystore(params.keyId); // encrypt using highest version of the key
    if(!key || key === '')
        return callback(new Error('KeyMaker-jweEncrypt- key not found'), null);

    var pubKeyPEM = utils.convertToPEMFormat(new Buffer(key.publicCerts[0], 'base64'), 1);

    pem.getPublicKey(pubKeyPEM.toString('ascii'), function (error, res) {
        if(error) {
            return callback(new Error('KeyMaker-jweEncrypt- unable to get public key from certificate. ', error), null);
        }
        var pubKeyJWK = pem2jwk(res.publicKey);
        var hash = '';
        var headerFields = {
            alg: params.alg,
            enc: params.enc
        };
        if (params.thumbprintHash === 'x5t') {
            hash = 'sha1';
        } else if (params.thumbprintHash === 'x5t#S256') {
            hash = 'sha256'
        }

        pem.getFingerprint(pubKeyPEM.toString('ascii'), hash, function (err, response) {
            if(hash === 'sha1' || hash === 'sha256') {
                if(err)
                    return callback(new Error('KeyMaker-jweEncrypt- error while creating thumbprint - ', err), null);
                headerFields[params.thumbprintHash] = (response && response.fingerprint || '').toString();
            }

            jose.JWE.createEncrypt({fields: headerFields}, pubKeyJWK).
            update(params.input).
            final().
            then(function (result) {
                if (!result)
                    return callback(new Error('KeyMaker-jweEncrypt- error in createEncrypt'), null);
                return callback(null, result);
            });
        });
    });
};

function isEncryptedWithCryptoserv(input){
    var header;
    if (JSON.stringify(input).lastIndexOf('{', 0) === 0) {
        header = JSON.parse(jose.util.base64url.decode(input.input.protected));
    } else {
        header = JSON.parse(base64.decode(input.split('.')[0], base64.CharacterSet.URLSAFE));
    }
    if (header) {
        var algo = header.alg;
        var enc = header.enc;
    }
    if(algo === 'dir' && enc === 'CryptoServ'){
        return true;
    }
    return false;
}

KeyMakerClient.prototype.jweDecrypt = function (params, callback) {
    if(isEncryptedWithCryptoserv(params)){
        var splitEncryptedData = params.split('.');
        var header = JSON.parse(base64.decode(splitEncryptedData[0], base64.CharacterSet.URLSAFE));
        var ciphertext = base64.decode(splitEncryptedData[3], base64.CharacterSet.URLSAFE);
        makeCsCall('decrypt', header.kid, ciphertext, callback);
        return;
    }
    if (!params || !params.input || !params.keyId || !params.alg || !params.enc) {
        return callback(new Error('KeyMaker-jweDecrypt- parameters missing! input, keyId, alg, and enc are mandatory parameters'), null);
    }
    
    getPrivateKey(params, function (err, key) {
        if (err)
            return callback(new Error('KeyMaker-jweDecrypt- error in getPrivateKey- ' + err), null);
        if(key.hasOwnProperty('p')) {
            // private key version determined based on the thumbprint
            createJweDecrypt(key, params.input, function (err, res) {
                if(err)
                    return callback(new Error('KeyMaker-jweDecrypt- unable to decrypt using key: ' + params.keyId + 'Error: ' + err), null);
                return callback(null, res);
            });
        } else {
            // try to decrypt with all versions of the key, until decryption is successful
            iterateOverVersions(key, params.input, createJweDecrypt, function (err, res) {
                if(err)
                    return callback(new Error('KeyMaker-jweDecrypt- unable to decrypt using key: ' + params.keyId + 'Error: ' + err), null);
                return callback(null, res);
            });
        }
    });
};

KeyMakerClient.prototype.jwsRFCSign = function (params, callback) {
    if (!params || !params.input || !params.keyId || !params.alg) {
        return callback(new Error('KeyMaker-jwsRFCSign- parameters missing! input, keyId, and alg are mandatory parameters'), null);
    }
    var key = getKeyfromKeystore(params.keyId); // get latest version of the key
    if(!key || key === '')
        return callback(new Error('KeyMaker-jwsRFCSign- key not found'), null);

    var privKeyDer = key.privateKey;
    var privKeyJWK = utils.derToJwk(privKeyDer);

    jose.JWS.createSign({alg: params.alg}, privKeyJWK).update(params.input).final().then(function (result) {
        if (!result)
            return callback(new Error('KeyMaker-jwsRFCSign- error in createSign'), null);

        var payload = result.payload;
        var header = result.signatures[0].protected;
        var signature = result.signatures[0].signature;
        var signed = header + "." + payload + "." + signature;
        return callback(null, signed);
    });
};

KeyMakerClient.prototype.jwsSign = function (params, callback) {
    if (!params || !params.input || !params.keyId || !params.alg) {
        return callback(new Error('KeyMaker-jwsSign- parameters missing! input, keyId, and alg are mandatory parameters'), null);
    }
    var key = getKeyfromKeystore(params.keyId); // get latest version of the key
    if(!key || key === '')
        return callback(new Error('KeyMaker-jwsSign- key not found'), null);

    var privKeyDer = key.privateKey;
    var privKeyJWK = utils.derToJwk(privKeyDer);

    jose.JWS.createSign({alg: params.alg}, privKeyJWK).update(params.input).final().then(function (result) {
        if (!result)
            return callback(new Error('KeyMaker-jwsSign- error in createSign'), null);
        return callback(null, result);
    });
};

KeyMakerClient.prototype.jwsVerify = function (params, callback) {
    if (!params || !params.input || !params.keyId || !params.alg) {
        return callback(new Error('KeyMaker-jwsVerify- parameters missing! input, keyId, and alg are mandatory parameters'), null);
    }
    var keys = getKeyfromKeystoreAll(params.keyId);
    if(!keys || keys === '')
        return callback(new Error('KeyMaker-jwsVerify- key not found'), null);

    // try to verify using all versions of public certicate, until verification is successful
    iterateOverVersions(keys, params.input, createJwsVerify, function (err, res) {
        if(err)
            return callback(new Error('KeyMaker-jwsVerify- unable to verify using key: ' + params.keyId + 'Error: ' + err), null);
        return callback(null, res);
    });
};

KeyMakerClient.prototype.encrypt = function(params, callback) {
    var res;
    var validationError = utils.validateInput(params);
    if (validationError) return callback(validationError, null);
    
    // For numeric key name, call cryproserv
    if(!isNaN(params.keyId)) return makeCsCall('encrypt', params.keyId, params.data, callback);

    try {
        if (params.data.constructor === Array) throw new Error('Batch-Encrypt Supported only in Agent Mode');
        res = localCrypto.encrypt(params.keyId, params.data);
        utils.checkEmptyResponse(res);
        return callback(null, res);
    } catch (e) {
        debug('Exception occurred in encrypt()', e);
        if (!isAgentEnabled) return callback(new Error('LocalCryptoFailed and AgentDisabled:' + e), null);
        params.encodedData = []; //encodedData List is expected by the agent
        if (params.data.constructor === Array) {
            params.isArray = true;
            for (var i in params.data) params.encodedData[i] = base64.encode(params.data[i]).toString();
        } else {
            params.isArray = false;
            params.encodedData[0] = base64.encode(params.data).toString();
        }
        return makeCall('encrypt', params, e, callback);
    }
};

KeyMakerClient.prototype.decrypt = function(params, callback) {
    var res;
    var validationError = utils.validateInput(params);
    if (validationError) return callback(validationError, null);

    // For numeric key name, call cryproserv
    if(!isNaN(params.keyId)) return makeCsCall('decrypt', params.keyId, base64.decode(params.data), callback);

    try {
        if (params.data.constructor === Array) throw new Error('Batch-Decrypt Supported only in Agent Mode');
        if (typeof params.data !== 'string') {
            var dataError = new Error('Input Invalid - request object param \'data\' should be string');
            return callback(dataError, null);
        }
        res = localCrypto.decrypt(params.keyId, base64.decode(params.data));
        utils.checkEmptyResponse(res);
        return callback(null, res);
    } catch (e) {
        debug('Exception occurred in decrypt()', e);
        if (!isAgentEnabled) return callback(new Error('LocalCryptoFailed and AgentDisabled:' + e), null);
        params.encodedData = []; //encodedData List is expected by the agent
        if (params.data.constructor === Array) {
            params.isArray = true;
            params.encodedData = params.data;
        }
        else {
            params.isArray = false;
            params.encodedData[0] = params.data;
        }
        return makeCall('decrypt', params, e, callback);
    }
};

KeyMakerClient.prototype.sign = function(params, callback) {
    var validationError = utils.validateInput(params);
    if (validationError) return callback(validationError, null);
    params.encodedData = []; //encodedData List is expected by the agent
    if (params.data.constructor === Array) {
        params.isArray = true;
        for (var i in params.data) params.encodedData[i] = base64.encode(params.data[i]).toString();
    } else {
        params.isArray = false;
        params.encodedData[0] = base64.encode(params.data).toString();
    }
    return makeCall('sign', params, '', callback);
};

KeyMakerClient.prototype.verify = function(params, callback) {
    var validationError = utils.validateInput(params, 'verify');
    if (validationError) return callback(validationError, null);
    params.encodedData = []; //encodedData List is expected by the agent
    if (params.data.constructor === Array) {
        params.isArray = true;
        for (var i in params.data) params.encodedData[i] = base64.encode(params.data[i]).toString();
        params.signedData = params.signed;
    } else {
        params.signedData = [];
        params.isArray = false;
        if (params.data) params.encodedData[0] = base64.encode(params.data).toString();
        params.signedData[0] = params.signed;
    }
    return makeCall('verify', params, '', callback);
};

KeyMakerClient.prototype.hmac = function(params, callback) {
    var res;
    var validationError = utils.validateInput(params);
    if (validationError) return callback(validationError, null);

    // For numeric key name, call cryproserv
    if(!isNaN(params.keyId)) return makeCsCall('hmac', params.keyId, params.data, callback);

    try {
        if (params.data.constructor === Array) throw new Error('Batch-Hmac Supported only in Agent Mode');
        res = localCrypto.hmac(params.keyId, params.data);
        utils.checkEmptyResponse(res);
        return callback(null, res);
    } catch (e) {
        debug('Exception occurred in hmac()', e);
        if (!isAgentEnabled) return callback(new Error('LocalCryptoFailed and AgentDisabled:' + e), null);
        params.encodedData = []; //encodedData List is expected by the agent
        if (params.data.constructor === Array) {
            params.isArray = true;
            for (var i in params.data) params.encodedData[i] = base64.encode(params.data[i]).toString();
        } else {
            params.isArray = false;
            params.encodedData[0] = base64.encode(params.data).toString();
        }
        return makeCall('hmac', params, e, callback);
    }
};

KeyMakerClient.prototype.seal = function(params, callback) {
    var res;
    var validationError = utils.validateInput(params);
    if (validationError) return callback(validationError, null);
    try {
        if (params.data.constructor === Array) throw new Error('Batch-Seal Supported only in Agent Mode');
        res = localCrypto.seal(params.cryptKeyId, params.macKeyId, params.data);
        utils.checkEmptyResponse(res);
        return callback(null, res);
    } catch (e) {
        debug('Exception occurred in seal()', e);
        if (!isAgentEnabled) return callback(new Error('LocalCryptoFailed and AgentDisabled:' + e), null);
        params.encodedData = []; //encodedData List is expected by the agent
        if (params.data.constructor === Array) {
            params.isArray = true;
            for (var i in params.data) params.encodedData[i] = base64.encode(params.data[i]).toString();
        } else {
            params.isArray = false;
            params.encodedData[0] = base64.encode(params.data).toString();
        }
        return makeCall('seal', params, e, callback);
    }
};

KeyMakerClient.prototype.unseal = function(params, callback) {
    var res;
    var validationError = utils.validateInput(params);
    if (validationError) return callback(validationError, null);
    try {
        if (params.data.constructor === Array) throw new Error('Batch-Unseal Supported only in Agent Mode');
        if (typeof params.data !== 'string') {
            var dataError = new Error('Input Invalid - request object param \'data\' should be string');
            return callback(dataError, null);
        }
        res = localCrypto.unseal(params.cryptKeyId, params.macKeyId, params.data);
        utils.checkEmptyResponse(res);
        return callback(null, res);
    } catch (e) {
        debug('Exception occurred in unseal()', e);
        if (!isAgentEnabled) return callback(new Error('LocalCryptoFailed and AgentDisabled:' + e), null);
        params.encodedData = []; //encodedData List is expected by the agent
        if (params.data.constructor === Array) {
            params.isArray = true;
            params.encodedData = params.data;
        }
        else {
            params.isArray = false;
            params.encodedData[0] = params.data;
        }
        return makeCall('unseal', params, e, callback);
    }
};

KeyMakerClient.prototype.getSecret = function(params, callback) {
    var res;
    var validationError = utils.validateInput(params, 'secretprovider');
    if (validationError) return callback(validationError, null);
    try {
        res = localCrypto.getSecret(params.keyId);
        utils.checkEmptyResponse(res);
        return callback(null, res);
    } catch (e) {
        debug('Exception occurred in getSecret()', e);
        if (!isAgentEnabled) return callback(new Error('LocalCryptoFailed and AgentDisabled:' + e), null);
        params.isArray = false;
        return makeCall('nonkey', params, e, callback);
    }
};

KeyMakerClient.prototype.ObjectIdEncrypt = function(data, config) {
    return localCrypto.ObjectIdEncrypt(data, config);
};

KeyMakerClient.prototype.ObjectIdDecrypt = function(data, config) {
    return localCrypto.ObjectIdDecrypt(data, config);
};

// An api basically to return the consolidatedTrustStore back to whoever would call create
// Well, create would be called only by 3 modules. (brogan/paypalize/typhon)
KeyMakerClient.prototype.getAllTrustedCerts = function() {
    try {
        var computedTrustedServers = keyStore.consolidatedTrustStoreRegistry.get('trustedCerts');
        if (computedTrustedServers) {
            debug('consolidated trustedCerts from keyMaker are \n', computedTrustedServers);
            return computedTrustedServers;
        }
        else {
            console.error('WARNING- keymakerclientapi- trustedCerts in keymaker cache is empty');
            return undefined;
        }
    } catch(e) {
        console.error('WARNING- keymakerclientapi- getAllTrustedCerts Exception-', e);
        return undefined;
    }
};

KeyMakerClient.prototype.getOutBoundExternalSSLConfig = function(params, callback) {
    try {
        if (!params.hasOwnProperty('keyId')) return callback(new Error('keyId property is mandatory, check api usage'), null);
        if (!params.keyId) return callback(new Error('keystore cannot be null'), null);

        // Make the response externalSSLConfig object struct
        var externalSSLConfig = utils.getDefaultExternalSSLConfigResponseObj();
        // change in the fallback hierarchy. Reason described elaborately here:
        // https://engineering.paypalcorp.com/confluence/display/PLATSEC/Node+KeyMakerClient+Design+Internals#
        // NodeKeyMakerClientDesignInternals-ExternalSSLConfigKeyStoreAccessOrderingetOutBoundSSLConfigAPI
        localCrypto.getOutBoundExternalSSLConfig(params.keyId, externalSSLConfig);

        return callback(null, externalSSLConfig);
    } catch (e) {
        debug('Exception occurred in getOutBoundExternalSSLConfig', e);
        // Here we First Check if agent is enabled and fallback on agent else we error out
        // because node vault doesn't impl. the concept of separate external keystores.
        if (!isAgentEnabled) return callback(new Error('external keystore from localcache failed and AgentDisabled.MoreInfo-' + e), null);
        params.internal_external = 'external';
        makeCall('sslconfig_outbound', params, e, function(error, res) {
            if (error) return callback(error, null);
            else {
                // Agent response is good and we start to process the agent response
                var isProcessed = processAgentResponse_sslConfigOutBound(res, params.keyId);
                // error in processing, we do the below
                if (isProcessed.error) return callback(isProcessed.error, null);
                else return callback(null, isProcessed.res);
            }
        });
    }
};

KeyMakerClient.prototype.getOutBoundExternalSSLConfigFromVault = function() {
    var calTxn = utils.createCalTransaction('protected_' + 'sslconfig_outbound', 'vaultOnly');
    var isProcessed = processVaultResponse_sslConfigOutBound();
    // if vault retrieval is having error, then return error
    if (isProcessed.error) {
        utils.writeCalEvent('sslconfig_outbound', 'vaultOnly', {
            error: isProcessed.error
        }, 'ERROR');
        return null;
    }
    if (calTxn) {
        calTxn.status = utils.getCalStatus('success');
        calTxn.complete();
    }
    return isProcessed.res;
};

KeyMakerClient.prototype.getSSOConfig = function(params, callback) {
    try {
        if (!params.hasOwnProperty('keyId')) return callback(new Error('keyId property is mandatory, check api usage'), null);
        if (!params.keyId) return callback(new Error('keystore name cannot be empty'), null);

        var keyStoreName = params.keyId;
        var ssoConfigFromLocalCache = keyStore.getLocalKeyMakerSSOKeyStore(keyStoreName);

        if (!ssoConfigFromLocalCache) throw new Error('getSSOConfig Response from LocalCache is Empty');

        return callback(null, ssoConfigFromLocalCache);
    } catch (e) {
        debug('Exception occurred in getSSOConfig', e);
        // Here we First Check if agent is enabled and fallback on agent else we error out
        // because node vault doesn't impl. the concept of separate external keystores.
        if (!isAgentEnabled) return callback(new Error('ssoKeyStore from localcache failed and AgentDisabled.MoreInfo-' + e), null);
        params.internal_external = 'external';
        params.calOpName = 'ssoconfig';
        makeCall('sslconfig_outbound', params, e, function(error, res) {
            if (error) return callback(error, null);
            else {
                //we start to process the agent response
                var ssoKMConfig = keyStore.processAgentSSOKeyStore(res);
                // some error in processing, processedResponse is null
                if (!ssoKMConfig) return callback(new Error('KeyMakerAgent ssoConfig processing Error'), null);
                else return callback(null, ssoKMConfig);
            }
        });
    }
};

KeyMakerClient.prototype.getAC = function(servername, callback) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'getAC', servername);
    if(!servername) {
        if (calTxn) {
            calTxn.addData('Error', 'servername must be specified');
            calTxn.status = utils.getCalStatus();
            calTxn.complete();
        }
        return callback(new Error('servername must be specified'));
    }
    var requestObject = {
        keyId: utils.getAppContextName(servername)
    };
    debug('getting application context: ' + requestObject.keyId);
    getClient().getSecret(requestObject, function (error, response) {
        if(error || !response) {
            if (calTxn) {
                calTxn.addData('Error', requestObject.keyId + ' application context not found. Error: ' + JSON.stringify(error));
                calTxn.status = utils.getCalStatus();
                calTxn.complete();
            }
            return callback(new Error(requestObject.keyId + ' application context not found. Error: ' + JSON.stringify(error)));
        }
        if (calTxn) {
            calTxn.status = utils.getCalStatus('success');
            calTxn.complete();
        }
        return callback(null, response.result.plainData.toString());
    });
};

KeyMakerClient.prototype.getExpiringAC = function(time, callback) {
    if(!time)
        time = 0;
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'getExpiringAC', time);
    var currentTime = Date.now();
    var expiringTime = currentTime + time;
    var expiringAC = [];
    keyStore.kmKeyCache.forEach(function(value, keyName) {
        if (keyName.endsWith('_exp')) {
            if(value <= expiringTime)
                expiringAC.push(keyName.slice(0, -4));
        }
    });
    if (calTxn) {
        calTxn.addData('expiringAC', expiringAC);
        calTxn.status = utils.getCalStatus('success');
        calTxn.complete();
    }
    return callback(null, expiringAC);
}

KeyMakerClient.prototype.refreshAC = function(appContextNames, callback) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'refreshAC', appContextNames);
    if (!appContextNames) {
        if (calTxn) {
            calTxn.addData('Error', 'application context names not provided');
            calTxn.status = utils.getCalStatus();
            calTxn.complete();
        }
        return callback(new Error('application context names not provided'));
    }
    var result = {};
    var counter = 0;
    var options = {};
    options.endpoint = '/kmsapi/v1/appcontext/refresh';
    options.method = 'GET';
    appContextNames.forEach(function(appContextName) {
        if(!keyStore.kmKeyCache.get(appContextName)){
            counter++;
            utils.writeCalEvent('refreshAC', appContextName, 'application context does not exist', 'WARNING');
            result[appContextName] = false;
            return returnRefreshedACs(counter, appContextNames.length, calTxn, result, callback);
        }

        options.appContextName = appContextName;
        options.appContext = keyStore.kmKeyCache.get(appContextName);
        makeKMApiCall(options, function(error, response) {
            counter++;
            if (error || !response) {
                utils.writeCalEvent('refreshAC', appContextName, error, 'WARNING');
                result[appContextName] = false;
            } else {
                response = JSON.parse(response);

                if(response && response.name && response.jwt && response.name === appContextName) {
                    keyStore.kmKeyCache.set(appContextName, response.jwt);
                    result[appContextName] = true;
                } else {
                    utils.writeCalEvent('refreshAC', appContextName, 'response does not contain JWT or the name does not match the name in the request', 'WARNING');
                    result[appContextName] = false;
                }
            }
            return returnRefreshedACs(counter, appContextNames.length, calTxn, result, callback);
        });
    });
}

function returnRefreshedACs(counter, length, calTxn, result, callback) {
    if (counter === length) {
        if(calTxn) {
            calTxn.addData('refreshed ACs', JSON.stringify(result));
            calTxn.status = utils.getCalStatus('success');
            calTxn.complete();
        } 
        return callback(null, result);
    }
}

KeyMakerClient.prototype.getRevokedAC = function(callback) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'getRevokedAC', utils.getAppName());
    if(!utils.getAppName()){
        if (calTxn) {
            calTxn.addData('Error', 'Application name not specified in package.json');
            calTxn.status = utils.getCalStatus();
            calTxn.complete();
        }
        return callback(new Error('Application name not specified in package.json'));
    }
    var options = {};
    options.endpoint = '/kmsapi/v1/appcontext/incoming/revoked/' + utils.getAppName();
    options.method = 'GET';
    makeKMApiCall(options, function (error, response) {
        if (error) {
            if (calTxn) {
                calTxn.addData('Error', error);
                calTxn.status = utils.getCalStatus();
                calTxn.complete();
            }
            return callback (new Error('Error in getRevokedAC: ' + error));
        }
        if (calTxn) {
            calTxn.addData('revoked AC list', response.toString());
            calTxn.status = utils.getCalStatus('success');
            calTxn.complete();
        }
        return callback(null, response.toString());
    });
}

KeyMakerClient.prototype.verifyPermission = function(appContextJWT, permissionsToCheck, callback) {
    var calTxn = utils.createCalTransaction(CAL_PROTECTED_TRANSACTION + 'verifyPermission', permissionsToCheck);
    if (!appContextJWT || !permissionsToCheck) {
        if (calTxn) {
            calTxn.addData('Error', 'Application context or permission not specified');
            calTxn.status = utils.getCalStatus();
            calTxn.complete();
        }
        return callback(new Error('Application context or permission not specified'));
    }
    var appContextJWTParts = appContextJWT.split('.');
    var appContextPayload = JSON.parse(base64.decode(appContextJWTParts[1]));

    var jti = appContextPayload.jti;
    if (isRevokedJTI(jti)) {
        if (calTxn) {
            calTxn.addData(appContextPayload.application_name, 'JTI is revoked');
            calTxn.status = utils.getCalStatus('success');
            calTxn.complete();
        }
        return callback(null, false);
    }
    
    var expiry = appContextPayload.exp;
    var softExpiry = appContextPayload.soft_expiry;
    if (expiry <= Date.now()) {
        if(softExpiry) {
            utils.writeCalEvent("APP_CTX_EXPIRED_SOFT_FAIL", appContextPayload.application_name, "soft expiry is true, hence ignoring the expiry", "WARNING");
        }
        else {   
            if (calTxn) {
                calTxn.addData(appContextPayload.application_name, 'Application context has expired');
                calTxn.status = utils.getCalStatus('success');
                calTxn.complete();
            }
            return callback(null, false);
        }
    }

    // verify AC
    var tenantName = appContextPayload.tenant_name;
    var keys = getKeyfromKeystoreAll(tenantName + '.ac.verify.certificate');
    var permissions = appContextPayload.permissions;
    if(!keys || keys === '') {
        if (calTxn) {
            calTxn.addData(tenantName, 'KeyMaker-verifyPermission- verification key not found');
            calTxn.status = utils.getCalStatus();
            calTxn.complete();
        }
        return callback(null, false);
    }
    // try to verify using all versions of public certicate, until verification is successful
    iterateOverVersions(keys, appContextJWT, createJwsVerify, function (err) {
        if(err) {
            if (calTxn) {
                calTxn.addData(appContextPayload.application_name, 'unable to verify AC. Error' + err);
                calTxn.status = utils.getCalStatus(); 
                calTxn.complete();
            }
            return callback(null, false);
        }
        for (var i = 0; i < permissionsToCheck.length; i++) {
            if (!checkPermission(permissions, permissionsToCheck[i])) {
                if (calTxn) {
                    calTxn.addData(appContextPayload.application_name, permissionsToCheck[i] + ' not granted');
                    calTxn.status = utils.getCalStatus('success'); 
                    calTxn.complete();
                }
                return callback(null, false); //atleast one permission not granted
            }
            if (i === permissionsToCheck.length - 1) {
                if (calTxn) {
                    calTxn.addData(appContextPayload.application_name, permissionsToCheck + ' granted');
                    calTxn.status = utils.getCalStatus('success'); 
                    calTxn.complete();
                }
                return callback(null, true); //all permissions were granted
            }
        }
    });
}

function checkPermission(permissions, permissionToCheck) {
    if (permissions.indexOf(permissionToCheck) <= -1) {
        return false;
    } else {
        return true;
    }
}

function isRevokedJTI(jti) {
    if (keyStore.revokedJTIList.indexOf(jti) > -1)
        return true;
    else
        return false;
}

function makeKMApiCall(options, callback) {
    var host = utils.getKeyMakerAPIhostport().host;
    var port = utils.getKeyMakerAPIhostport().port;
    var calTxn = utils.createCalTransaction('CONNECT', host + ':' + port);
    var trustedCertificates = keyStore.keymakerapiCert;
    var requestOptions = {
        hostname: host,
        port: port,
        path: options.endpoint,
        method: options.method,
        ca: trustedCertificates,
        rejectUnauthorized: true
      };

      if (options.appContext) {
        requestOptions.headers = {
            'X-KM-APP-CONTEXT': options.appContext
        };
      }
      var req = https.request(requestOptions, function (res) {
        if(calTxn) {
            calTxn.addData('Status code', res.statusCode);
            calTxn.addData('Header', JSON.stringify(res.headers));
            calTxn.status = utils.getCalStatus('success');
            calTxn.complete();
        }
        if (res.statusCode !== 200)
            return callback(new Error("Status code: " + res.statusCode));
        res.on('data', function (d) {
          return callback(null, d);
        });
      });

      req.end();

      req.on('error', function (e) {
        if(calTxn) {
            calTxn.addData('Error', e);
            calTxn.status = utils.getCalStatus();
            calTxn.complete();
        }
        return callback(new Error(e));
      });
}

function getClient() {
    if (instantiated) return kmsclient;
    // instantiation status is false here
    if (deployEnv.isNotDev()) {
        console.error(GET_CLIENT_ERR_MSG + 'km_key_fetch Failed.');
        utils.writeCalEvent('km_get_client', 'asyn_client', GET_CLIENT_ERR_MSG + 'km_key_fetch Failed.', 'ERROR');
    }
    else {
        console.error(GET_CLIENT_ERR_MSG + 'Either vault_key_fetch [OR] km_key_fetch Failed.');
        utils.writeCalEvent('km_get_client', 'asyn_client', GET_CLIENT_ERR_MSG + 'Either vault_key_fetch [OR] km_key_fetch Failed.', 'ERROR');
    }

    return kmsclient; //returns back kmsclient with vault cache loaded at the least for NON-DEV env.
}

function getKeyMakerAPIcert() {
    var location = process.env.keymakerapiCertPath || '/x/web/LIVE/keymaker/certs/keymakerapi_cert.pem'
    fs.readFile(location, function(err, cert){
        if (err)
            debug("Unable to read keymakerapi cert");
        keyStore.keymakerapiCert = cert;
    });
}
// create function to be invoked only by brogan or paypalize module for initializing
// keymakerclient. Client code will only call getClient() to get the keymakerclient object
module.exports = {
    create: function(options, callback) {
        var env;
        if (process.env.DEPLOY_ENV) env = process.env.DEPLOY_ENV;

        // Prepare user supplied options for CAL logging
        options = options || {};
        if (options && options.cryptoservprotocol) utils.setCryptoservProtocol(options.cryptoservprotocol); // since protocol has a white space, setting it before replacing all white spaces in options
        var optionsStr = 'options=' + JSON.stringify(options);
        optionsStr = optionsStr.replace(/ /g, '');
        optionsStr = optionsStr.replace(/"/g, '');

        var calTxn = utils.createCalTransaction(CAL_KEYMAKER_TRANSACTION + 'create', optionsStr);
        // Return back error obj in callback if invoked multiple times and log the same
        if (isInvokedMultipleTimes) {
            console.error('KeyMakerClient:create can be called only once.');
            if (calTxn) {
                calTxn.addData('KeyMakerClient:create', 'Invoked Multiple times, should be invoked only once from brogan OR paypalize');
                calTxn.complete();
            }
            return callback(undefined, undefined);
        }
        // We set this flag to true to make sure create can be called just once
        isInvokedMultipleTimes = true;

        var initTimeOut = options && options.initTimeOut && typeof options.initTimeOut === 'number' ? options.initTimeOut : 5000;

        // Async vault create function
        var opt = {};
        if (!options.unitTest) {
            var conf = shush(Path.join(process.cwd(), 'config/config.json'));
            opt = conf.vault || {};
        }
        if(process.env.DEPLOY_ENV) {
            // The below IF block would be used only during create api testing scenario
            // Ideally the 'changeToVaultTestConfig' property wouldn't get passed from
            // the callers of KeyMaker create api. 
            if (options.hasOwnProperty('changeToVaultTestConfig')) opt = options.changeToVaultTestConfig;

            // vault module expects DEPLOY_ENV and appName to be passed as input params for NON_DEV mode
            opt.env = process.env.DEPLOY_ENV;
            opt.name = utils.getAppName();
            debug(JSON.stringify(opt));
        }
        vault.create(opt, function(err, pkg) {
            var isValid, error;
            if (err) {
                isValid = false;
                error = err;
            } else {
                var pkgValidation = utils.validatePkg(pkg);
                isValid = pkgValidation.isValid;
                error = pkgValidation.error;
            }
            if (isValid) {
                options.credentials = pkg.getClientCredentials();
                options.secret = pkg.get('encrypted_keymaker_agent_passphrase').toString();
                options.appname = options.appname && typeof options.appname === 'string' ? options.appname : utils.getAppName();
                options.sessions = pkg.get('client_sessions');
                options.secretKeys = pkg.getEncryptedAll();
                options.algos = pkg.getAlgoAll();
                utils.setProtectedUserName(pkg.get('username'));
                
                isKeyMaker_HardFailure_Enabled = pkg.getString('keymaker_hard_failure_enabled');
                if (typeof isKeyMaker_HardFailure_Enabled === 'undefined') isKeyMaker_HardFailure_Enabled = false;
                kmsclient = new KeyMakerClient(options);
                infraCryptoClient = new infraCryptoAPIProvider();
                // All Good so far, we log that vault cache is built successfully
                console.log('km_init_step1- vault cache load successful.');
                utils.writeCalEvent('create', 'km_init_step1', 'vault cache Load successful');
            } else {
                // Handles vault related error and any exception that could occur while constructing kmsclient
                // We HALT startup only for NON_DEV environment.
                console.error('Critical Failure[1] keymaker_create : Construction Failed ENV=' + env + '&HardFailure=' + isKeyMaker_HardFailure_Enabled);
                console.error('Critical Failure[1] ' + error);
                utils.writeCalEvent('create', 'km_init_step1_' + env + '_HardFailure_' + isKeyMaker_HardFailure_Enabled, {
                    error: error
                }, 'ERROR');
                if (deployEnv.isNotDev()) {
                    if (calTxn) calTxn.complete();
                    throw new Error('Critical Failure[1]' + BOOTSTRAP_FAILURE_MSG + error);
                } else {
                    console.error('Critical Failure[1] Not-Interrupting Application Bootstrap in DEV Mode, keymaker object would be undefined.');
                    // We return back null error_msg to make sure paypalize tests don't break by any chance and we
                    // will look up the error info from the console error logs.
                    // This has been done based on prior experience with paypalize tests breaking for similar reasons.
                    return callback(null, kmsclient);
                }
            }
            // Agent disabled mode, we dont have connection pool created and we dont make get_exportable_keys call
            if(!isAgentEnabled) {
                instantiated = true;
                console.error('KeyMaker Warning: User Requested to Disable Agent. Are you sure about what you are doing?');
                utils.writeCalEvent('create', 'vault_keys_fetched', keyStore.snapOfCache());
                if (calTxn) {
                    calTxn.status = utils.getCalStatus('success');
                    calTxn.complete();
                }
                return callback(null, kmsclient);
            }

            getKeyMakerAPIcert();
            // Async Agent Function
            getKeysFromAgent(initTimeOut, function(error, response) {
                try {
                    // get key cache path, PIN, and KEK for local key cache support
                    keyCachePath = utils.getProtectedPath(opt);
                    keyCachePath = keyCachePath + '/keymaker_cache.enc';
                    pin = utils.getKEK(opt.name);
                    pin = utils.base64Decode(pin);
                    kek = utils.unwrap(pkg.get('b64_aes_key'), pin.slice(0, 16));
                    var str_response;
                    // Here we skip checks on error object as the python agent responds back with the complete error
                    // in the response object itself. python module doesn't follow node-style of callback.
                    if (!response) throw new Error('No Response From Agent');
                    // Deal with response_code !== 200
                    else if (response.response_code !== 200) {
                        str_response = JSON.stringify(response);
                        utils.writeCalEvent('create', KEY_EXPORT_FAILURE_MSG + env, str_response, 'ERROR');
                        throw new Error(str_response);
                    }
                    // Deal with response_code === 200 but result field not found in response
                    else if (!response.result) {
                        str_response = 'Unexpected Error-result field not found ' + JSON.stringify(response);
                        utils.writeCalEvent('create', KEY_EXPORT_FAILURE_MSG + env, str_response, 'ERROR');
                        throw new Error(str_response);
                    }
                    // Deal with response_code === 200 and result field found but could possibly have an AppMissing or Identity
                    // Missing Error. These errors if present would be logged in CAL but startup will not be affected
                    else if (Object.keys(response.result).length === 0) {
                        str_response = JSON.stringify(response);
                        utils.writeCalEvent('create', KEY_EXPORT_FAILURE_MSG + env, str_response, 'ERROR');
                    }
                    // Deal with all Ok scenario by processing keys
                    else {
                        processKeyData(response.result);
                        // Create local key cache file in the protected package location. Replace if it already exists to refresh key data
                        // Encrypt response with KEK and store in file
                        var keymakerCacheEncrypted = localCrypto.encryptLocalKeyCache(kek, JSON.stringify(response.result));
                        fs.writeFile(keyCachePath, keymakerCacheEncrypted.result.encodedData, function (err) {
                            if(err)
                                console.log('km_init_step2- Unable to save local key cache. Error: ' + err);
                            else
                                console.log('km_init_step2- Key cache saved locally.');
                        });
                        console.log('km_init_step2- KeyMaker and Vault Cache Load successful.');
                        utils.writeCalEvent('create', 'km_init_step2', 'KeyMaker and Vault Cache Load successful.');
                        utils.writeCalEvent('create', 'keys_fetched', keyStore.snapOfCache());
                    }
                    instantiated = true;
                    if (calTxn) calTxn.status = utils.getCalStatus('success');
                    return callback(null, kmsclient);
                } catch (e) {
                    // No response from agent. Try again.
                    console.error('Warning: keymaker_create : Construction Failed ENV=' + env + '&HardFailure=' + isKeyMaker_HardFailure_Enabled);
                    console.error('Warning: ' + e);
                    console.log('km_init_step2- Trying to get keys from agent again');
                    utils.writeCalEvent('create', 'km_init_step2', 'Trying to get keys from agent again');
                    getKeysFromAgent(initTimeOut, function (error, response) {
                        if(!response || response.response_code !== 200 || !response.result || Object.keys(response.result) === 0) {
                            instantiated = false;
                            console.error('Critical Failure[2] keymaker_create : Construction Failed ENV=' + env + '&HardFailure=' + isKeyMaker_HardFailure_Enabled);
                            utils.writeCalEvent('create', KEY_EXPORT_FAILURE_MSG + env + '_HardFailure_' + isKeyMaker_HardFailure_Enabled, {
                                error: e,
                            }, 'ERROR');
                        } else {
                            // got response from agent in 2nd try
                            processKeyData(response.result);
                            // Create local key cache file in the protected package location. Replace if it already exists to refresh key data
                            // Encrypt response with KEK and store in file
                            var keymakerCacheEncrypted = localCrypto.encryptLocalKeyCache(kek, JSON.stringify(response.result));
                            fs.writeFile(keyCachePath, keymakerCacheEncrypted.result.encodedData, function (err) {
                                if (err)
                                    console.log('km_init_step2- Unable to save local key cache. Error: ' + err);
                                else
                                    console.log('km_init_step2- Key cache saved locally.');
                            });
                            console.log('km_init_step2- KeyMaker and Vault Cache Load successful.');
                            utils.writeCalEvent('create', 'km_init_step2', 'KeyMaker and Vault Cache Load successful.');
                            utils.writeCalEvent('create', 'keys_fetched', keyStore.snapOfCache());
                            instantiated = true;
                            if (calTxn) calTxn.status = utils.getCalStatus('success');
                            return callback(null, kmsclient);
                        }
                    });
                   // Check if local key cache exists
                    utils.writeCalEvent('create', KEY_EXPORT_FAILURE_MSG + env, 'Checking if local key cache exists');
                    utils.checkLocalKeyCacheExists(keyCachePath, function (local_key_cache_exists) {
                        if (local_key_cache_exists) {
                            utils.writeCalEvent('create', KEY_EXPORT_FAILURE_MSG + env, 'Local key cache found!');
                            instantiated = true;
                            fs.readFile(keyCachePath, 'UTF-8', function (err, response) {
                                if (err) {
                                    console.error('Critical Failure[2] keymaker_create : Construction Failed ENV=' + env + ' Local key cache found but unable to read it');
                                    utils.writeCalEvent('create', BOOTSTRAP_FAILURE_MSG, 'Error in reading local key cache', 'ERROR');
                                    throw new Error('Critical Failure[2]' + BOOTSTRAP_FAILURE_MSG + err);
                                }
                                // Successfully read local key cache
                                // Decrypt local key cache with Key Encryption Key (b64_aes_key)
                                var res = localCrypto.decryptLocalKeyCache(kek, base64.decode(response));
                                utils.checkEmptyResponse(res);
                                // Successfully retrieved local key cache. Process key data as usual.
                                processKeyData(JSON.parse(res.result.plainData));
                                // log the timestamp and age of local key cache in logs
                                utils.logTimestamp(keyCachePath);
                                console.log('km_init_step2- KeyMaker [local key cache] and Vault Cache Load successful.');
                                utils.writeCalEvent('create', 'km_init_step2', 'KeyMaker [local key cache] and Vault Cache Load successful.');
                                utils.writeCalEvent('create', 'keys_fetched', keyStore.snapOfCache());
                                return callback(null, kmsclient);
                            });
                        } else {
                            // local key cache not found
                            instantiated = false;
                            console.error('Critical Failure[2] keymaker_create : No local key cache found');
                            utils.writeCalEvent('create', KEY_EXPORT_FAILURE_MSG + env + '_HardFailure_' + isKeyMaker_HardFailure_Enabled, {
                                error: e,
                            }, 'ERROR');
                            if (deployEnv.isNotDev()) {
                                // Throw error if hard failure is enabled and it is not DEV environment
                                if (isKeyMaker_HardFailure_Enabled) throw new Error('Critical Failure[2]' + BOOTSTRAP_FAILURE_MSG + e);
                            }
                            return callback(null, kmsclient);
                        }
                    });
                } finally {
                    if (calTxn) calTxn.complete();
                }
            });
        });
    },
    getClient: getClient,
    // Should not be used by client applications. Used only by Paypalize module for keymaker shortstop handler
    getClientForInfra: function () {
        return kmsclient;
    },
    // To be Used ONLY by Legacy Infra Middlewares, not for client/customer usage.
    getInfraCryptoAPI: function () {
        if(instantiated) return infraCryptoClient;
        // instantiation status is false here
        if (deployEnv.isNotDev()) {
            console.error(GET_CLIENT_ERR_MSG + 'km_key_fetch Failed.');
            utils.writeCalEvent('km_get_client', 'syn_client', GET_CLIENT_ERR_MSG + 'km_key_fetch Failed.', 'ERROR');
        }
        else {
            console.error(GET_CLIENT_ERR_MSG + 'Either vault_key_fetch [OR] km_key_fetch Failed.');
            utils.writeCalEvent('km_get_client', 'syn_client', GET_CLIENT_ERR_MSG + 'Either vault_key_fetch [OR] km_key_fetch Failed.', 'ERROR');
        }

        return infraCryptoClient; //returns back kmsclient with vault cache loaded at the least for NON-DEV env.
    },
    getPayPalTransformedCCnumberBytes: function(cc_number_string) {
        if(cc_number_string.length > 19) throw new Error('CC number greater than 19 digits as String');

        var ccNumberLong = Long.fromString(cc_number_string, true, 10);

        if(ccNumberLong < Long.UZERO) throw new Error('Invalid input: Number greater than what Long can accommodate');
        
        var ccNumberHex = ccNumberLong.toString(16);
        if(ccNumberHex.length % 2 !== 0)
            ccNumberHex = '0' + ccNumberHex;
        
        var ccNumberBuffer = new Buffer(ccNumberHex, 'hex');
        return ccNumberBuffer;
    },
    revertPayPalTransformedCCnumberBytes: function(cc_number_buffer) {
        // Expecting decrypted result from cryptoserv here
        var ccNumberLong = Long.fromString(cc_number_buffer.toString('hex'), true, 16);
        return ccNumberLong.toString(10);
    },
    cryptoservToJWE: function (encryptedData, keyId){
        if (!encryptedData || !keyId ) {
            throw new Error('KeyMaker-getJWTForCryptoservDecrypt- parameters missing! encryptedData, keyId are mandatory parameters');
        }
        
        // Ciphertext
        var ciphertext = base64.encode(encryptedData, base64.CharacterSet.URLSAFE);
    
        //protected
        var header = {};
        header.alg = 'dir';
        header.kid = keyId;
        header.enc = 'CryptoServ';
        header = base64.encode(JSON.stringify(header), base64.CharacterSet.URLSAFE);
        
        return header + '.' + '.' + '.' + ciphertext + '.';
    },
    shutdown: function() {
        // Fire & Forget API to nuke the persistent connections that were set up with
        // the keymakeragent. Ensures graceful shutdown of keymaker
        if (!instantiated) {
            console.log('KEYMAKER_SHUTDOWN: keymaker is not up and running ...');
            return;
        }
        if(cryptoservPool){
            cryptoservPool.drain(function() {
                cryptoservPool.destroyAllNow();
                console.log('Cryptoserv Pool Destroyed for KEYMAKER_SHUTDOWN');
            });
        }

        if(!pool) {
            console.log('KEYMAKER_SHUTDOWN: No cleanup Required as keymakerclient started in Agent Disabled Mode !!');
            return;
        }

        pool.drain(function() {
            pool.destroyAllNow();
            console.log('KEYMAKER_SHUTDOWN: Triggered !!');
        });

        return;
    }
};
