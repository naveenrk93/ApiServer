'use strict';

/**
 * Implements functions needed to perform a successful connection to cryptoserv and make
 * Crypto Api call offered by cryptoserv
 * 
 * NOTE: 
 * 1. Data To and From cryptoserv binary data and thus to being handled using Buffer
 * Make sure you store data using """ new Buffer(data, 'binary')  """ where 'binary'
 * specifies encoding to be used. Similarly Netstring read and write should too mention
 * encoding as 'binary'
 * 
 * 2. Nestring.read() method returns an array of netstring messages. In case of single
 * message, unless UTF-8 of it is intended to be used, specifically use data at index 0
 * and convert it to right encoding.
 * 
 */

var NetString = require('netstring-stream'),
    base64 = require('base64-paypal'),
    utils = require('./utils'),
    connectionUtils = require('./connectionUtils');
// CRYPTOSERV_CORRELATION_ID_COMMAND
var CORRELATION_ID_COMMAND = 2006;

// Cryptoserv Api commands
var CS_API_COMMAND_MAP = {
    'decrypt': 4,   //CRYPTOSERV_CLIENT_DECRYPT_COMMAND
    'hmac': 5,      //CRYPTOSERV_CLIENT_HMAC_COMMAND
    'encrypt': 6    //CRYPTOSERV_CLIENT_ENCRYPT_COMMAND
};

// Cryptoserv response commands
var CS_RESPONSE_COMMAND_MAP = {
    'decrypt': 9,   //CRYPTOSERV_DECRYPTED_BUFFER
    'hmac': 11,     //CRYPTOSERV_HMAC_BUFFER
    'encrypt': 12   //CRYPTOSERV_ENCRYPTED_BUFFER
};

/** Create connection pool for cryptoserv 
 * @param {JSON} defaultOptions Created in connectionPool same like agent
 * @returns {JSON} Object with config specific to Cryptoserv
 */
function getCryptoservConnPoolConfig(defaultOptions) {
    var cryptoservOptions = defaultOptions || {};

    // Modify Cryptoserv specific properties
    cryptoservOptions.isCryptoservPool = true;

    // Get Cryptoserv endpoint from topo
    var csConf = utils.getCryptoservhostport();
    utils.writeCalEvent('csInfo', 'cryptoserv_topo_config', JSON.stringify(csConf));

    cryptoservOptions.host = csConf.host;
    cryptoservOptions.port = csConf.port;

    return cryptoservOptions;
}

/* ================================= Call Cryptoserv API ==================================== */

/**
 * Call cryptoserv to perform requested operation
 * The methods starts with the Handshake with Custom auth followed by Api call
 * 
 * @param {ConnectionPool} pool Pool object created at startup in KeyMakerClient
 * @param {string} appName Application name
 * @param {string} operation Crypto Operation to be performed: 'encrypt', 'decrypt', 'hmac'
 * @param {string} keyId Key ID for the key to be used for the operation
 * @param {Buffer} inputData byte buffer passed by client
 * @param {callback} callback to be returned
 * 
 * @returns {callback} Callback with result : error OR data
 */

function callCryptoserv(pool, appName, operation, keyId, inputData, callback) {
    var calOperationName = 'protected_' + operation;
    var calTxn = utils.createCalTransaction(calOperationName, keyId);
    if (calTxn) var correlationId = utils.getCorrelationId();

    // Input validation
    if (!keyId || !inputData) {
        return callback(new Error('KeyMakerClient - callCryptoserv: keyId and inputData is mandatory'), null);
    }
    if (inputData.constructor === Array) {        
        return callback(new Error('Found array input: Batch operations not supported'), null);
    }
    var request = { operation: operation, keyId: keyId, inputData: inputData };

    /**
     * If minPoolSize is 0, the connection pooling is off
     * Connection pooling is OFF by default
     * Don't acquire a socket from the pool, instead, create a socket for each cryptoserv API call, and 
     * destroy socket once error or response is received
     * This is done as pool.destroy() does not check for waiting requests, and if the client sends
     * requests > maxPoolSize, only the requests equal to maxPoolSize will be served
     * Remaining go in a wait state forever
     * pool.release() does check for waiting requests
     */
    if (pool.getMinPoolSize() === 0) {
        var config = connectionUtils.constructCryptoservConfig(utils.getCsPoolConfig());
         connectionUtils.createSocket(config, function(error, socket){
            if (error) {
                writeCalError(calOperationName, keyId, error);
                return callback(error, null);
            }
            callCryptoservApi(appName, socket, request, correlationId, function (err, res){
                if(err) {
                    // Write error to CAL
                    utils.writeCalEvent(calOperationName, keyId, err, 'ERROR');
                    if (calTxn) calTxn.status = utils.getCalStatus();
                } else if (calTxn) calTxn.status = utils.getCalStatus('success');

                // Destroy the socket and complete CAL Txn
                socket.netStream.unpipe(socket);
                socket.destroy();
                socket.netStream.end();
                if (calTxn) calTxn.complete();

                return callback(err, res);
            });
        }); 
    } else { // Connection pooling is ON (csMinConn > 0 in config)
    // Log pool status before acquire
    var message = 'Pool status BEFORE acquiring socket- ' + 'poolSize:' + pool.getPoolSize() + ' & ' + 'available:' + pool.availableObjectsCount() + 
    ' & ' + 'inUse:' + pool.inUseObjectsCount() + ' & ' + 'waiting:' + pool.waitingClientsCount();
    utils.writeCalEvent(pool.getName(), appName + ':' + keyId, message);

    // Acquire connection from pool
    pool.acquire(function(err, client) {
        if (err) {
            writeCalError(calOperationName, keyId, err);
            return callback(err, null);
        }

        // Call Cryptoserv: Do Handshake followed by API call using async waterfall
        callCryptoservApi(appName, client, request, correlationId, function (err, result) {

            if(err) {
                // Write error to CAL
                utils.writeCalEvent(calOperationName, keyId, err, 'ERROR');
                if (calTxn) calTxn.status = utils.getCalStatus();
                // Destroy socket if there is an error. Pool will re-create if required
                client.netStream.unpipe(client);
                client.netStream.end();
                pool.destroy(client);
            } else {
                if (calTxn) calTxn.status = utils.getCalStatus('success');
                // Release the acquired connection
                client.netStream.unpipe(client);
                client.netStream.end();
                pool.release(client);
            }
            if (calTxn) calTxn.complete();
            return callback(err, result);
        });
    });
}
}

/**
 * Call Cryptoserv Api to perform crypto operation after successful socket creation & custom authentication
 * 
 * @param {TLSSocket} client TLS connection from pool
 * @param {JSON} request Contains operation, keyId, inputData
 * @param {callback} next 
 */
function callCryptoservApi(appName, client, request, correlationId, next) {
    // Bind Events
    client.on('timeout', onTimeout);
    client.on('error', onError);
    client.on('data', onReceive);
    client.on('close', onClose);

    connectionUtils.init(client);
    // Send correlation id to Cryptoserv
    client.netStream.write(getCorrelationIdMessage(appName, correlationId));

    // Call crypto api
    var apiCall = getCSApiCall(request.operation, request.keyId, request.inputData);
    client.netStream.write(apiCall, 'binary');

    function onReceive(data) {
        client.removeListener('data', onReceive);
        client.removeListener('timeout', onTimeout);
        client.removeListener('error', onError);
        client.removeListener('close', onClose);
        
        if (!data) {
            return next(new Error("Result from cryptoserv is empty"), null);
        }
        var result = getFinalResult(NetString.read(data)[0], request.operation, request.keyId);
        if(result.error_code) {
            return next(result, null);
        }
        return next(null, result);
    }

    function onError(error) {
        client.removeListener('data', onReceive);
        client.removeListener('timeout', onTimeout);
        client.removeListener('error', onError);
        client.removeListener('close', onClose);
        return next(error, null);
    }

    function onTimeout() {
        // Remove listener and report error
        client.removeListener('data', onReceive);
        client.removeListener('timeout', onTimeout);
        client.removeListener('error', onError);
        client.removeListener('close', onClose);
        return next(new Error("timeout when calling cryptoserv"), null);
    }

    function onClose() {
        // Remove listener and report error
        client.removeListener('data', onReceive);
        client.removeListener('timeout', onTimeout);
        client.removeListener('error', onError);
        client.removeListener('close', onClose);
        return next(new Error("connection to cryptoserv closed"), null);
    }
}

/**
 * Form Correlation Id message which is of the form
 * 2006 corr_id=CorrelationID&PoolStack=appNameFromPackageJson
 * 
 * @param {String} appName Name of the application from package.json
 */
function getCorrelationIdMessage(appName, correlationId) {
    return CORRELATION_ID_COMMAND + ' ' +
            'corr_id=' + correlationId + '&' +
            'PoolStack=' + appName;
}

/**
 * Form Cryptoserv Api request of the form "API_COMMAND two_byte_key_id_followed_by_inputdata"
 * 
 * @param {string} operation Crypto Operation to be performed: 'encrypt', 'decrypt', 'hmac'
 * @param {string} keyId Name of the key
 * @param {Buffer} inputData Data on which operation is to be performed
 * 
 * @returns {Buffer}
 */
function getCSApiCall(operation, keyId, inputData) {
    var csApi = CS_API_COMMAND_MAP[operation];
    var commandSpace = connectionUtils.getBinaryBuffer(csApi + ' ');

    // Convert key to network byte order
    var networkOrderKeyId = getUnsigned16bit(parseInt(keyId, 10));

    return Buffer.concat([commandSpace, networkOrderKeyId, connectionUtils.getBinaryBuffer(inputData)]);
}


/** 
* Convert input unsigned integer to 16 bit equivalent buffer
* Opted not to use Uint16Array as typed array operate with 
* endianness of host computer
*
* @param number Unsigned Integer not more than 16 bit long
*
* @returns buffer with two bytes
*/
function getUnsigned16bit(number) {
    var twoByteHex = number.toString(16);
    if(twoByteHex.length < 4) {
        var padding = 4 - twoByteHex.length;
        while(padding > 0) {
            twoByteHex = '0' + twoByteHex;
            padding--;
        }
    } 

    return new Buffer(twoByteHex, 'hex');
}

/**
 * Create a final response to send to client
 * 
 * @param {Buffer} result result from Cryptoserv
 * @param {string} operation Crypto operation performed
 * @param {string} keyId Key used
 * 
 * @returns {JSON} Object to be sent back to client
 */
 function getFinalResult(result, operation, keyId) {
    var response = connectionUtils.parseCSResponse(result);
    var command = response.command;

    if(command === CS_RESPONSE_COMMAND_MAP[operation]) {
        // Successful operation
        var finalResult = utils.getResponseObj(base64.encode(response.data).toString(), operation, keyId);
        if(operation === 'decrypt') finalResult.result.plainData = response.data;
        return finalResult;
    }

    // Reached here means cryptoserv returned error
    return getErrorJson(command);
} 

/**
 * Form JSON with error details: {code, message}
 * 
 * @param {number} command Error command returned by cryptoserv
 * @returns {JSON} Object with error details
 */
function getErrorJson(command) {
    return {
        error_code: command,
        error_message: connectionUtils.getCSError(command)
    };
}

/**
 * Write message to the CAL as ERROR
 * 
 * @param {string} operation operation being performed
 * @param {string} keyId key being used
 * @param {string} err error message
 */
function writeCalError(operation, keyId, err) {
    utils.writeCalEvent(operation, keyId, {
        error: err
    }, 'ERROR');
}

module.exports = {
    getCryptoservConnPoolConfig: getCryptoservConnPoolConfig,
    callCryptoserv: callCryptoserv
};

