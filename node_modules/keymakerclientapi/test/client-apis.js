'use strict';
var assert = require('assert');
var base64 = require('base64-paypal');
var cal = require('cal');
var KeyMakerClient = require('../index');
var testUtils = require('../lib/utils');
var vault = require('vault');
var topos = require('topos');
var nconf = require('nconf');
var kmClient;
var numOfRuns = 1;
var perfTest = true;

// Test Data vars
var vaultData = {};
vaultData.objectIdEncryption_13chars_cryptKey;
vaultData.objectIdEncryption_13chars_macKey;
var testResultData = {};
testResultData.desEncryptOutput;
testResultData.aes128EncryptOutput;
testResultData.aes256EncryptOutput;
testResultData.sealdesxsha1Output;
testResultData.rsaSignOutput;
testResultData.AsymEncryptOutput;
testResultData.AsymEncryptOutputList;
testResultData.PKCS7EncryptOutput;
testResultData.gcmEncryptOperation;
testResultData.gcmEncrypt35CharsOperation;
testResultData.gcmEncrypt32CharsOperation;
testResultData.gcmEncrypt256CryptKeyOperation;
testResultData.gcmEncrypt128CryptKeyOperation;
testResultData.gcmEncrypt4CharsOperation;

cal.setDefaultWriteStream('console');


function contains(haystack, needle) {
    var n = haystack.indexOf(needle);
    if (n > 0) {
        return true;
    } else {
        return false;
    }
}
describe('keymaker-api-positive', function() {
    // setting up vault
    before('test-setup', function(next) {
        //process.stdout.setMaxListeners(12 + 1);
        console.time('test-setup');
        this.timeout(20000);
        process.env.SHARE_PWD = 'aardvark';
        //setting the below DEPLOY_ENV will read keystore from protected dir instead of testkeystore
        //process.env.DEPLOY_ENV = 'DEV';
        var opt = {};
        opt.appname = 'keymakerapiclientnodeapp';
        opt.unitTest = true;
        //opt.isAgentEnabled = false;
        //opt.host = '127.0.0.1';
        //opt.host = '10.57.123.16';
        //opt.initTimeOut = 5000;
        
        // Initialize topo
        topos.init(nconf.get('topos'), nconf);

        KeyMakerClient.create(opt, function(err, obj) {
            if (err) {
                console.log('client-tests err obj: ' + err);
            }
            kmClient = obj;
            console.timeEnd('test-setup');
            next();
        });
    });
    for (var i = 0; i < numOfRuns; i++) {
        it('assert when create called second time', function(next) {
            KeyMakerClient.create({}, function(error, obj) {
                assert(error === undefined, 'error is expected to be undefined');
                assert(obj === undefined, 'response is expected to be undefined');
                next();
            });
        });

        it('kmclient and infraCryptoAPI returns object after keymaker bootstrap', function(next) {
            var kmclient2 = KeyMakerClient.getClient();
            assert.strictEqual(kmclient2 && typeof kmclient2, 'object', 'expected a kmclient object');
            var infraCryptoAPIprovider2 = KeyMakerClient.getInfraCryptoAPI();
            assert.strictEqual(infraCryptoAPIprovider2 && typeof infraCryptoAPIprovider2, 'object', 'expected a InfraCryptoAPIprovider object');
            next();
        });
        //faulty test due to mackey found for GCM impl - might have to remove after confirmation from team
        it('encrypt-dataGT100chars-with-testgcmkey', function(next) {
            var requestObject = {
                keyId: 'encrypted_test_aes_gcm_crypt_key',
                data: new Buffer('arun kumar elengovan is a the developer who worked on this client and this is a real huge text to encrypt'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncryptOperation = res.result.encodedData;
                next();
            });
        });
        //faulty test due to mackey found for GCM impl - might have to remove after confirmation from team
        it('decrypt-dataGT100chars-with-testgcmkey', function(next) {
            var requestObject = {
                keyId: 'encrypted_test_aes_gcm_crypt_key',
                data: testResultData.gcmEncryptOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = 'arun kumar elengovan is a the developer who worked on this client and this is a real huge text to encrypt';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encrypt-4chars-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: new Buffer('1234'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncrypt4CharsOperation = res.result.encodedData;
                next();
            });
        });

        it('decrypt-4chars-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: testResultData.gcmEncrypt4CharsOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = '1234';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encrypt-32chars-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: new Buffer('12345678909876543212345678909876'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncrypt32CharsOperation = res.result.encodedData;
                next();
            });
        });

        it('decrypt-32chars-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: testResultData.gcmEncrypt32CharsOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = '12345678909876543212345678909876';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encrypt-35chars-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: new Buffer('12345678909876543211234567890098123'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncrypt35CharsOperation = res.result.encodedData;
                next();
            });
        });

        it('decrypt-35chars-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: testResultData.gcmEncrypt35CharsOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = '12345678909876543211234567890098123';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encrypt-largeData-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: new Buffer('arun kumar elengovan is a the developer who worked on this client and this is a real huge text to encrypt'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncrypt256CryptKeyOperation = res.result.encodedData;
                next();
            });
        });

        it('decrypt-largeData-gcm-with-256_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_256_crypt_key',
                data: testResultData.gcmEncrypt256CryptKeyOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = 'arun kumar elengovan is a the developer who worked on this client and this is a real huge text to encrypt';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encrypt-4chars-gcm-with-128_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_128_crypt_key',
                data: new Buffer('1234'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncrypt128CryptKey4CharsOperation = res.result.encodedData;
                next();
            });
        });

        it('decrypt-4chars-gcm-with-128_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_128_crypt_key',
                data: testResultData.gcmEncrypt128CryptKey4CharsOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = '1234';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encrypt-35chars-gcm-with-128_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_128_crypt_key',
                data: new Buffer('12345678909876543212345678909876123'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncrypt128CryptKeyOperation = res.result.encodedData;
                next();
            });
        });

        it('decrypt-35chars-gcm-with-128_crypt_key', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_128_crypt_key',
                data: testResultData.gcmEncrypt128CryptKeyOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = '12345678909876543212345678909876123';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encrypt-128cryptKey-GT100Chars-gcm-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_128_crypt_key',
                data: new Buffer('arun kumar elengovan is a the developer who worked on this client and this is a real huge text to encrypt'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-encrypt-operation-test ***', error, res);
                testResultData.gcmEncrypt128CryptKeyOperation = res.result.encodedData;
                next();
            });
        });

        it('decrypt-128cryptKey-GT100Chars-gcm-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_aes_gcm_128_crypt_key',
                data: testResultData.gcmEncrypt128CryptKeyOperation,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                var expectedText = 'arun kumar elengovan is a the developer who worked on this client and this is a real huge text to encrypt';
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** gcm-decrypt-operation-test ***', error, res);
                assert(base64.decode(res.result.encodedData).toString() === expectedText, 'should match plain text after decode');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === expectedText, 'should match plain text');
                console.log(res.result.plainData.toString());
                next();
            });
        });

        it('encryptOperation-with-KeyFromVault', function(next) {
            var requestObject = {
                keyId: 'encrypted_rlogid_crypt_key',
                data: new Buffer('testData'),
                isPKCS7: false
            };
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** vaultKey-encrypt-operation-test ***', error, res);
                testResultData.vault_rlogId_EncData = res.result.encodedData;
                assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                next();
            });
        });

        it('decryptOperation-with-KeyFromVault', function(next) {
            var requestObject = {
                keyId: 'encrypted_rlogid_crypt_key',
                data: testResultData.vault_rlogId_EncData,
                isPKCS7: false
            };
            kmClient.decrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** vaultKey-decrypt-operation-test ***', error, res);
                assert(res.result.plainData.toString() === 'testData', 'decrypt api output expected to be testData');
                next();
            });
        });

        it('des-encrypt-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_crypt_key',
                data: new Buffer('arunkuma'),
                isPKCS7: false
            };
            console.time('des-encrypt-operation');
            kmClient.encrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** des-encrypt-operation-test ***', error, res);
                console.timeEnd('des-encrypt-operation');
                testResultData.desEncryptOutput = res.result.encodedData;
                assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('aes128-encrypt-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_cookie_bag_crypt_key',
                data: new Buffer('1234567887654321'),
                isPKCS7: false
            };
            console.time('aes128-encrypt-operation');
            kmClient.encrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes128-encrypt-operation-test ***', error, res);
                console.timeEnd('aes128-encrypt-operation');
                testResultData.aes128EncryptOutput = res.result.encodedData;
                console.log(typeof res.result.encodedData);
                assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('aes256-encrypt-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_yamsession_crypt_key',
                data: new Buffer('12345678876543211234567887654321'),
                isPKCS7: false
            };
            console.time('aes256-encrypt-operation');
            kmClient.encrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes256-encrypt-operation-test ***', error, res);
                console.timeEnd('aes256-encrypt-operation');
                testResultData.aes256EncryptOutput = res.result.encodedData;
                assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('des-decrypt-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_crypt_key',
                data: testResultData.desEncryptOutput,
                isPKCS7: false
            };
            console.time('des-decrypt-operation');
            kmClient.decrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** des-decrypt-operation-test ***', error, res);
                console.timeEnd('des-decrypt-operation');
                assert(base64.decode(res.result.encodedData).toString() === 'arunkuma', 'expected to be equal');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === 'arunkuma', 'expected to be equal');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('des-decrypt-operation-diffencoding', function(next) {
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_crypt_key',
                data: 'iGPVfH0ZrNo=',
                isPKCS7: false
            };
            console.time('des-decrypt-operation');
            kmClient.decrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** des-decrypt-operation-test ***', error, res);
                console.timeEnd('des-decrypt-operation');
                assert(base64.decode(res.result.encodedData).toString() === 'thetést', 'expected to be equal');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString('hex') === '74686574c3a97374', 'expected to be equal');
                assert(res.result.plainData.toString() === 'thetést', 'expected to be equal');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('aes128-decrypt-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_cookie_bag_crypt_key',
                data: testResultData.aes128EncryptOutput,
                isPKCS7: false
            };
            console.time('aes128-decrypt-operation');
            kmClient.decrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes128-decrypt-operation-test ***', error, res);
                console.timeEnd('aes128-decrypt-operation');
                assert(base64.decode(res.result.encodedData).toString() === '1234567887654321', 'expected to be equal');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === '1234567887654321', 'expected to be equal');
                next();
            });
        });
        it('aes256-decrypt-operation', function(next) {
            var requestObject = {
                keyId: 'encrypted_yamsession_crypt_key',
                //data: ['zBxYWv/0QczU8H9pFDmRNh943e6FPewa5TP6pGh8tzKVWBkUwLF8qOPkWXIQKefW'],
                data: testResultData.aes256EncryptOutput,
                isPKCS7: false
            };
            console.time('aes256-decrypt-operation');
            kmClient.decrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes256-decrypt-operation-test ***', error, res);
                console.timeEnd('aes256-decrypt-operation');
                assert(base64.decode(res.result.encodedData).toString() === '12345678876543211234567887654321', 'expected to be equal');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === '12345678876543211234567887654321', 'expected to be equal');
                next();
            });
        });
        it('des-encrypt-operation-list', function(next) {
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_crypt_key',
                //keyId: 'encrypted_foosball_beacon_crypt_key', //offlinetesting
                data: [new Buffer('arunkuma')],
                isPKCS7: false
            };
            console.time('des-encrypt-operation');
            kmClient.encrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** des-encrypt-operation-test ***', error, res);
                console.timeEnd('des-encrypt-operation');
                testResultData.desEncryptOutput = res.result.encodedData;
                assert(typeof res.result.encodedData[0] === 'string', 'encrypt api output expected to be a string');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('aes128-encrypt-operation-list', function(next) {
            var requestObject = {
                keyId: 'encrypted_cookie_bag_crypt_key',
                data: [new Buffer('1234567887654321')],
                isPKCS7: false
            };
            console.time('aes128-encrypt-operation');
            kmClient.encrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes128-encrypt-operation-test ***', error, res);
                console.timeEnd('aes128-encrypt-operation');
                testResultData.aes128EncryptOutput = res.result.encodedData;
                assert(typeof res.result.encodedData[0] === 'string', 'encrypt api output expected to be a string');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('aes256-encrypt-operation-list', function(next) {
            var requestObject = {
                keyId: 'encrypted_yamsession_crypt_key',
                data: [new Buffer('12345678876543211234567887654321')],
                isPKCS7: false
            };
            console.time('aes256-encrypt-operation');
            kmClient.encrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes256-encrypt-operation-test ***', error, res);
                console.timeEnd('aes256-encrypt-operation');
                testResultData.aes256EncryptOutput = res.result.encodedData;
                assert(typeof res.result.encodedData[0] === 'string', 'encrypt api output expected to be a string');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('des-decrypt-operation-list', function(next) {
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_crypt_key',
                data: testResultData.desEncryptOutput,
                isPKCS7: false
            };
            console.time('des-decrypt-operation');
            kmClient.decrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** des-decrypt-operation-test ***', error, res);
                console.timeEnd('des-decrypt-operation');
                assert(base64.decode(res.result.encodedData[0]).toString() === 'arunkuma', 'expected to be equal');
                assert(res.result.plainData[0] instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData[0].toString() === 'arunkuma', 'expected to be equal');
                // While you uncomment the following sleep, make sure to 
                // modify reapIntervals and idleMillis to 1 ms.
                // asyncTesting.sleep(1);
                next();
            });
        });
        it('aes128-decrypt-operation-list', function(next) {
            var requestObject = {
                keyId: 'encrypted_cookie_bag_crypt_key',
                data: testResultData.aes128EncryptOutput,
                isPKCS7: false
            };
            console.time('aes128-decrypt-operation');
            kmClient.decrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes128-decrypt-operation-test ***', error, res);
                console.timeEnd('aes128-decrypt-operation');
                assert(base64.decode(res.result.encodedData[0]).toString() === '1234567887654321', 'expected to be equal');
                assert(res.result.plainData[0] instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData[0].toString() === '1234567887654321', 'expected to be equal');
                next();
            });
        });
        it('aes256-decrypt-operation-list', function(next) {
            var requestObject = {
                keyId: 'encrypted_yamsession_crypt_key',
                //data: ['zBxYWv/0QczU8H9pFDmRNh943e6FPewa5TP6pGh8tzKVWBkUwLF8qOPkWXIQKefW'],
                data: testResultData.aes256EncryptOutput,
                isPKCS7: false
            };
            console.time('aes256-decrypt-operation');
            kmClient.decrypt(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                }
                console.log('*** aes256-decrypt-operation-test ***', error, res);
                console.timeEnd('aes256-decrypt-operation');
                assert(base64.decode(res.result.encodedData[0]).toString() === '12345678876543211234567887654321', 'expected to be equal');
                assert(res.result.plainData[0] instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData[0].toString() === '12345678876543211234567887654321', 'expected to be equal');
                next();
            });
        });
        it('asymmetric-encrypt-operation', function(next) {
            console.time('asymmetric-encrypt-operation');
            var requestObject = {
                keyId: 'mykey3',
                data: new Buffer('arunkumar'),
                isPKCS7: false
            };
            //Make the TCP call using NetString Protocol
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                testResultData.AsymEncryptOutput = res.result.encodedData;
                console.log('*** asymmetric-encrypt-operation-test ***', error, res);
                console.timeEnd('asymmetric-encrypt-operation');
                next();
            });
        });
        it('asymmetric-decrypt-operation', function(next) {
            console.time('asymmetric-decrypt-operation');
            var requestObject = {
                keyId: 'mykey3',
                data: testResultData.AsymEncryptOutput,
                isPKCS7: false
            };
            //Make the TCP call using NetString Protocol
            kmClient.decrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(res.result.plainData.toString() === 'arunkumar', 'Expected plainData to match');
                assert(res.result.plainData instanceof Buffer, 'Expected plainData to be a Buffer');
                console.log('*** asymmetric-decrypt-operation-test ***', error, res);
                console.timeEnd('asymmetric-decrypt-operation');
                next();
            });
        });
        it('asymmetric-encrypt-list-operation', function(next) {
            console.time('asymmetric-encrypt-list-operation');
            var requestObject = {
                keyId: 'mykey3',
                data: [new Buffer('arunkumar')],
                isPKCS7: false
            };
            //Make the TCP call using NetString Protocol
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(typeof res.result.encodedData[0] === 'string', 'encrypt api output expected to be a string');
                testResultData.AsymEncryptOutputList = res.result.encodedData;
                console.log('*** asymmetric-encrypt-list-operation-test ***', error, res);
                console.timeEnd('asymmetric-encrypt-list-operation');
                next();
            });
        });
        it('asymmetric-decrypt-list-operation', function(next) {
            console.time('asymmetric-decrypt-list-operation');
            var requestObject = {
                keyId: 'mykey3',
                data: testResultData.AsymEncryptOutputList,
                isPKCS7: false
            };
            //Make the TCP call using NetString Protocol
            kmClient.decrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(res.result.plainData[0].toString() === 'arunkumar', 'Expected plainData to match');
                assert(res.result.plainData[0] instanceof Buffer, 'Expected plainData to be a Buffer');
                console.log('*** asymmetric-decrypt-list-operation-test ***', error, res);
                console.timeEnd('asymmetric-decrypt-list-operation');
                next();
            });
        });
        it('pkcs7-encrypt-operation', function(next) {
            console.time('pkcs7-encrypt-operation');
            var requestObject = {
                keyId: 'mykey3',
                data: new Buffer('arunkumar'),
                isPKCS7: true
            };
            //Make the TCP call using NetString Protocol
            kmClient.encrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                testResultData.PKCS7EncryptOutput = res.result.encodedData;
                console.log('*** pkcs7-encrypt-operation-test ***', error, res);
                console.timeEnd('pkcs7-encrypt-operation');
                next();
            });
        });
        it('pkcs7-decrypt-operation', function(next) {
            console.time('pkcs7-decrypt-operation');
            var requestObject = {
                keyId: 'mykey3',
                data: testResultData.PKCS7EncryptOutput,
                isPKCS7: true
            };
            //Make the TCP call using NetString Protocol
            kmClient.decrypt(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(res.result.plainData.toString() === 'arunkumar', 'Expected plainData to match');
                assert(res.result.plainData instanceof Buffer, 'Expected plainData to be a Buffer');
                console.log('*** pkcs7-decrypt-operation-test ***', error, res);
                console.timeEnd('pkcs7-decrypt-operation');
                next();
            });
        });
        it('rsa-sign-operation', function(next) {
            console.time('rsa-sign-operation');
            var requestObject = {
                keyId: 'mykey3',
                //keyId: 'testkeypair_test',
                data: new Buffer('arunkumar'),
                isPKCS7: false
            };
            //Make the TCP call using NetString Protocol
            kmClient.sign(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                console.log('*** rsa-sign-operation-test ***', error, res);
                console.timeEnd('rsa-sign-operation');
                assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                testResultData.rsaSignOutput = res.result.encodedData;
                next();
            });
        });
        it('rsa-verify-operation', function(next) {
            console.time('rsa-verify-operation');
            var requestObject = {
                keyId: 'mykey3',
                //keyId: 'testkeypair_test',
                data: new Buffer('arunkumar'),
                signed: testResultData.rsaSignOutput
            };
            //Make the TCP call using NetString Protocol
            kmClient.verify(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(res.result.isVerified === true, 'expected to be false');
                assert(typeof res.result.isVerified === 'boolean', 'encrypt api output expected to be a string');
                console.log('*** rsa-verify-operation-test ***', error, res);
                console.timeEnd('rsa-verify-operation');
                next();
            });
        });
        it('rsa-sign-operation-list', function(next) {
            console.time('rsa-sign-operation-list');
            var requestObject = {
                keyId: 'mykey3',
                //keyId: 'testkeypair_test',
                data: [new Buffer('arunkumar')],
                isPKCS7: false
            };
            //Make the TCP call using NetString Protocol
            kmClient.sign(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(typeof res.result.encodedData[0] === 'string', 'encrypt api output expected to be a string');
                console.log('*** rsa-sign-operation-test ***', error, res);
                console.timeEnd('rsa-sign-operation-list');
                next();
            });
        });
        it('rsa-verify-operation-list', function(next) {
            var input = 'AB25VWMHg4lyUoNUuRRwJL9y5gLP6m92IhFrvonAN/xAb0kk5LTSr8nhDEldcHu9PeCIjLkPY+7OH/hKgKTr0n5nSoevFt+2Pzf1eshpi2LXvd0HuhxL6X8eASD2V79hY3JBkvWAAD3fPpQu3pmPVb7Gud8bqNH3nEjfJRt2p/RbatjQpmM3YwcFBSfW1c/fyp64gqGzXc3BeIcURdx5zAyhvzIQtBCPBPTYjqWXHLRRp55p1FCimeN0KA9Mhh1Q4Z7lMF/a8LSzz4RG6sEkX/43U/LrwPFmxv6MfhHYRDMuFzwoMu0ijHO97anStBgeANbmaK0YUloQajsg/GpwPw==';
            console.time('rsa-verify-operation-list');
            var requestObject = {
                keyId: 'mykey3',
                //keyId: 'testkeypair_test',
                data: [new Buffer('arunkumar')],
                signed: [input]
            };
            //Make the TCP call using NetString Protocol
            kmClient.verify(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(res.result.isVerified[0] === false, 'expected to be false');
                assert(typeof res.result.isVerified[0] === 'boolean', 'encrypt api output expected to be a string');
                console.log('*** rsa-verify-operation-test ***', error, res);
                console.timeEnd('rsa-verify-operation-list');
                next();
            });
        });
        it('hmac-operation', function(next) {
            console.time('hmac-operation');
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_mac_key',
                data: new Buffer('12345678')
            };
            kmClient.hmac(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                    assert(res.result.encodedData === 'BZFVnN3tbICbnJSHzMGDnAaqgIA=', 'expected to be equal');
                }
                console.log('*** hmac-operation-test ***', error, res);
                console.timeEnd('hmac-operation');
                next();
            });
        });
        it('hmac-operation-list', function(next) {
            console.time('hmac-operation-list');
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_mac_key',
                data: [new Buffer('12345678')]
            };
            kmClient.hmac(requestObject, function(error, res) {
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                    assert(res.result.encodedData[0] === 'BZFVnN3tbICbnJSHzMGDnAaqgIA=', 'expected to be equal');
                }
                console.log('*** hmac-operation-test ***', error, res);
                console.timeEnd('hmac-operation-list');
                next();
            });
        });
        it('hmac-keyVersion', function(next) {
            console.time('hmac-keyVersion');
            var requestObject = {
                keyId: 'encrypted_test_cryptutil_mac_key',
                data: new Buffer('12345678')
            };
            kmClient.hmac(requestObject, function(error, res) {
                console.log('*** hmac-keyVersion ***', error, res);
                if (perfTest) {
                    assert(!error, 'No error');
                    assert(res.response_code === 200);
                    assert(res.result);
                    assert(res.result.encodedData === 'BZFVnN3tbICbnJSHzMGDnAaqgIA=', 'expected to be equal');
                    assert(res.result.version, 'key version is expected in response');
                }
                console.timeEnd('hmac-keyVersion');
                next();
            });
        });
        it('seal-operation', function(next) {
            console.time('seal-operation');
            var requestObject = {
                cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
                macKeyId: 'encrypted_test_cryptutil_mac_key',
                data: new Buffer('arunkumar')
            };
            kmClient.seal(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                //assert(res.result.keyId === requestObject.keyId);
                console.log('*** seal-operation-test ***', error, res);
                console.timeEnd('seal-operation');
                testResultData.sealdesxsha1Output = res.result.encodedData;
                next();
            });
        });
        it('unseal-operation', function(next) {
            console.time('unseal-operation');
            var requestObject = {
                cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
                macKeyId: 'encrypted_test_cryptutil_mac_key',
                data: testResultData.sealdesxsha1Output
            };
            console.log(testResultData.sealdesxsha1Output);
            kmClient.unseal(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** unseal-operation-test ***', error, res);
                console.timeEnd('unseal-operation');
                assert(base64.decode(res.result.encodedData).toString() === 'arunkumar', 'expected to be equal');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === 'arunkumar', 'expected to be equal');
                next();
            });
        });
        it('seal-operation-list', function(next) {
            console.time('seal-operation');
            var requestObject = {
                cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
                macKeyId: 'encrypted_test_cryptutil_mac_key',
                data: [new Buffer('arunkumar')]
            };
            kmClient.seal(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                //assert(res.result.keyId === requestObject.keyId);
                console.log('*** seal-operation-test ***', error, res);
                console.timeEnd('seal-operation');
                testResultData.sealdesxsha1Output = res.result.encodedData;
                next();
            });
        });
        it('unseal-operation-list', function(next) {
            console.time('unseal-operation');
            var requestObject = {
                cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
                macKeyId: 'encrypted_test_cryptutil_mac_key',
                data: testResultData.sealdesxsha1Output
            };
            console.log(testResultData.sealdesxsha1Output);
            kmClient.unseal(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** unseal-operation-test ***', error, res);
                console.timeEnd('unseal-operation');
                assert(base64.decode(res.result.encodedData[0]).toString() === 'arunkumar', 'expected to be equal');
                assert(res.result.plainData[0] instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData[0].toString() === 'arunkumar', 'expected to be equal');
                next();
            });
        });
        it('seal-operation-aes128', function(next) {
            console.time('seal-operation-aes128');
            var requestObject = {
                cryptKeyId: 'encrypted_acnw_mayfly_risk_crypt_key',
                macKeyId: 'encrypted_acnw_mayfly_risk_mac_key',
                data: new Buffer('thisissimple')
            };
            kmClient.seal(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                //assert(res.result.keyId === requestObject.keyId);
                console.log('*** seal-operation-aes128 ***', error, res);
                console.timeEnd('seal-operation-aes128');
                testResultData.sealaes128Output = res.result.encodedData;
                next();
            });
        });
        it('unseal-operation-aes128', function(next) {
            console.time('unseal-operation-aes128');
            var requestObject = {
                cryptKeyId: 'encrypted_acnw_mayfly_risk_crypt_key',
                macKeyId: 'encrypted_acnw_mayfly_risk_mac_key',
                data: testResultData.sealaes128Output
            };
            console.log(testResultData.sealdesxsha1Output);
            kmClient.unseal(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                console.log('*** unseal-operation-aes128 ***', error, res);
                console.timeEnd('unseal-operation-aes128');
                assert(base64.decode(res.result.encodedData).toString() === 'thisissimple', 'expected to be equal');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === 'thisissimple', 'expected to be equal');
                next();
            });
        });
        it('secretprovider-operation', function(next) {
            console.time('secretprovider-operation');
            var requestObject = {
                keyId: 'encrypted_devplat_oracle_password'
            };
            kmClient.getSecret(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(base64.decode(res.result.encodedData).toString() === 'devplatappstg', 'expected to be equal');
                assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                assert(res.result.plainData.toString() === 'devplatappstg', 'expected to be equal');
                console.log('*** secretprovider-operation-test ***', error, res);
                console.timeEnd('secretprovider-operation');
                next();
            });
        });
        it('secretprovider-operation-non-secret', function(next) {
            console.time('secretprovider-operation-non-secret');
            var requestObject = {
                keyId: 'encrypted_rlogid_mac_key'
            };
            kmClient.getSecret(requestObject, function(error, res) {
                assert(error, 'Error expected');
                assert(res.response_code === 400);
                assert(!res.result, 'result is not expected');
                console.timeEnd('secretprovider-operation-non-secret');
                next();
            });
        });
        it('pkcs7-sign-operation-list', function(next) {
            console.time('pkcs7-sign-operation');
            var requestObject = {
                keyId: 'crypto_unit_test_pkcs7_keypair',
                data: [new Buffer('arunkumar')],
                isPKCS7: true
            };
            kmClient.sign(requestObject, function(error, res) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                console.log('*** pkcs7-sign-operation-test ***', error, res);
                console.timeEnd('pkcs7-sign-operation');
                next();
            });
        });
        it('pkcs7-verify-operation-list', function(next) {
            console.time('pkcs7-verify-operation');
            var requestObject = {
                keyId: 'crypto_unit_test_pkcs7_keypair',
                data: [],
                signed: ['LS0tLS1CRUdJTiBQS0NTNy0tLS0tCk1JSUdFUVlKS29aSWh2Y05BUWNDb0lJR0FqQ0NCZjRDQVFFeEN6QUpCZ1VyRGdNQ0dnVUFNQmdHQ1NxR1NJYjMKRFFFSEFhQUxCQWxoY25WdWEzVnRZWEtnZ2dOV01JSURVakNDQWpxZ0F3SUJBZ0lHQVY4U0puTGdNQTBHQ1NxRwpTSWIzRFFFQkN3VUFNR294RFRBTEJnTlZCQU1NQkZSbGMzUXhEVEFMQmdOVkJBc01CRlJsYzNReEZUQVRCZ05WCkJBb01ERkJoZVZCaGJDd2dTVzVqTGpFUk1BOEdBMVVFQnd3SVUyRnVJRXB2YzJVeEV6QVJCZ05WQkFnTUNrTmgKYkdsbWIzSnVhV0V4Q3pBSkJnTlZCQVlUQWxWVE1CNFhEVEUzTVRBeE1qRTVNREF3TUZvWERUSTNNVEF4TWpFNQpNREF3TUZvd2FqRU5NQXNHQTFVRUF3d0VWR1Z6ZERFTk1Bc0dBMVVFQ3d3RVZHVnpkREVWTUJNR0ExVUVDZ3dNClVHRjVVR0ZzTENCSmJtTXVNUkV3RHdZRFZRUUhEQWhUWVc0Z1NtOXpaVEVUTUJFR0ExVUVDQXdLUTJGc2FXWnYKY201cFlURUxNQWtHQTFVRUJoTUNWVk13Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQgpBUURIZHJjTjU0ZW5nelVPN1VlZjhOS3Y4VTk3MW9FWXpSdndOeXBQTWFRWFFvZnV5L1FERTQ3ZHhWWlZxcVhuCnZkU2JiQ2c2NkIxZnBsSlpaVVdDK3c0SzFkTFB0b2d0WWFRZitrbXQrQ0lSSGdrNVhWZm40Yng0NU52VjlTQUoKMjIzUlI0RkNGbml3Wm1CSkxXZWtmUENiTEx3cWpDWlV4Sng2cFA2TkV1d3hDVHI0WUpOVmg2dlU2Ym42eC9ocQpHbjJDWVh0OVFWZHFWeFd2ZnlTNjFCQWRGNHNhRlBISnlVN1Z2WTZOUXA1TVlISWh6UWI2c1ordXpTOG8rdnpMCnJzQjBqaHBBU2NzRFd0SlhkWTR4U2x5bjRQVE10UXNtQVBycjV5SXhhNklNZ3hGUTJSWnpudHhtQ0VDV01nc3cKU3RtYWxXc0dnS011UmhITXErWXE1YmtQQWdNQkFBRXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBRW5BY096Vgowc1l6VU14aDVjSGFDZm9qdzBpamRGd1FjSmlZb0xXcU03ckN4SUVLbnMvTmJZSW1GS2x2SjNhK204QUlIMVpYCkxWNGtITzl5R2xFWHhoN1hOY2lxNnUrM1BnYjlNRVAyeVFzZHFIbXVFWnJZdi9USXNoVWRhRDZQOUVKQjE5clMKblpLSkVwNjZqWG9GTlI1V3JNdFRsdlZlSkxCeFVrVEVRVUFCQU1NUDV0SFJUSU9Za0MzZkhZVXhWMVNxbHQrOQpQR1lvLzhYVjVDMEpGbmM0STdrcGF1cWkzd01kbkdaMzV5YW5ZdFJPZVRkUktUTENtWDRnOHNpL25hMk5FZXpvCkNQZ3p2UDNSKzM2WS9kUmRFOEZ4ejArVG5wUlhMUFNXNXNtaUUrMXIzOHVOMzFENmJsU2M5U1orYTBnQVRldFkKT0tGSVRDZ2ZXOEhHaGhveGdnSjJNSUlDY2dJQkFUQjBNR294RFRBTEJnTlZCQU1NQkZSbGMzUXhEVEFMQmdOVgpCQXNNQkZSbGMzUXhGVEFUQmdOVkJBb01ERkJoZVZCaGJDd2dTVzVqTGpFUk1BOEdBMVVFQnd3SVUyRnVJRXB2CmMyVXhFekFSQmdOVkJBZ01Da05oYkdsbWIzSnVhV0V4Q3pBSkJnTlZCQVlUQWxWVEFnWUJYeEltY3VBd0NRWUYKS3c0REFob0ZBS0NCMkRBWUJna3Foa2lHOXcwQkNRTXhDd1lKS29aSWh2Y05BUWNCTUJ3R0NTcUdTSWIzRFFFSgpCVEVQRncweE56RXdNekF5TWpJNE5EZGFNQ01HQ1NxR1NJYjNEUUVKQkRFV0JCUndYajlWRytId0hkekdIMnE0ClZOYlgwVW83eHpCNUJna3Foa2lHOXcwQkNROHhiREJxTUFzR0NXQ0dTQUZsQXdRQktqQUxCZ2xnaGtnQlpRTUUKQVJZd0N3WUpZSVpJQVdVREJBRUNNQW9HQ0NxR1NJYjNEUU1ITUE0R0NDcUdTSWIzRFFNQ0FnSUFnREFOQmdncQpoa2lHOXcwREFnSUJRREFIQmdVckRnTUNCekFOQmdncWhraUc5dzBEQWdJQktEQU5CZ2txaGtpRzl3MEJBUUVGCkFBU0NBUUEwdGRERyt2RVpTdU51N01OSUpkbHdkRjkzOVo1enQrM3dML09ZUEhrR0JZN1g3Zzh2ZmZmbUpwL24Kd1E0THZSSVkwOURGalBocDRKaXBXbE5oUVVEWDNRVHYxR2E4Z2E5RUJ3eERnSnhOK1hTRUd6eU5xVWthOG03QgpSZk0yam14RDhvN3BkNjhJUnl2UjIyZ1hpQVk5OGZpMkcrN0RBTSsralBnYk5OR3Q4eCtOUzFOdzVtWHhneWtRCkJmSHlzZXcwR0ErRGgrY2M3dkZPalc4MGVZZFJSdWxYdFV6U2FwMlhIdXVmYlpZdkRFNHExZHNsMFE2NXFyY2IKV3VSUE5QWnJDSzJlQkFRWHludjdhblN3UC9aeTUwM1JXWnhsbzc5OTJGcnQ0bngycXMwajVnSkJKblYrWkR0OApNNmF2MEF4UkNjOU82ZXlseStBKytIZ3pjSUxKCi0tLS0tRU5EIFBLQ1M3LS0tLS0K']
            };
            kmClient.verify(requestObject, function(error, res) {
                console.log('*** pkcs7-verify-operation-test ***', error, res);
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(res.result.isVerified[0] ===  true, 'should be true')
                console.log('*** pkcs7-verify-operation-test ***', error, res);
                console.timeEnd('pkcs7-verify-operation');
                next();
            });
        });

        it('should encrypt a 13-char object id-legacyWay', function(next) {
            vault.create({}, function(err, pkg) {
                if (err) {
                    console.log('Error in vault.create: ', err);
                } else {
                    var ObjectIDEncryptor_config = {
                        key: pkg.get('encrypted_account_number_code_crypt_key'),
                        iv: pkg.get('encrypted_account_number_code_mac_key')
                    };
                    vaultData.objectIdEncryption_13chars_cryptKey = ObjectIDEncryptor_config.key;
                    vaultData.objectIdEncryption_13chars_macKey = ObjectIDEncryptor_config.iv;
                    var data = '2027531847140704400';
                    var expectedResponse = '5ADZMJYM2EMFL';
                    // ObjectIDEncryptor_config.type = 'PLAIN';
                    var response = kmClient.ObjectIdEncrypt(data, ObjectIDEncryptor_config);
                    assert.equal(response, expectedResponse);
                }
                next();
            });
        });

        it('should decrypt a 13-char encrypted object id-legacyWay', function(next) {
            var ObjectIDEncryptor_config = {
                key: vaultData.objectIdEncryption_13chars_cryptKey,
                iv: vaultData.objectIdEncryption_13chars_macKey
            };
            var data = '5ADZMJYM2EMFL';
            var expectedResponse = '2027531847140704400';
            // ObjectIDEncryptor_config.type = 'PLAIN';
            var response = kmClient.ObjectIdDecrypt(data, ObjectIDEncryptor_config);
            assert.equal(response, expectedResponse);
            next();
        });

        it('should encrypt a 13-char object id-keymakerWay', function(next) {
            var ObjectIDEncryptor_config = {
                keyName: 'encrypted_account_number_code_crypt_key'
            };
            var data = '2027531847140704400';
            var expectedResponse = '5ADZMJYM2EMFL';
            // ObjectIDEncryptor_config.type = 'PLAIN';
            var response = kmClient.ObjectIdEncrypt(data, ObjectIDEncryptor_config);
            assert.equal(response, expectedResponse);
            next();
        });

        it('should decrypt a 13-char encrypted object id-keymakerWay', function(next) {
            var ObjectIDEncryptor_config = {
                keyName: 'encrypted_account_number_code_crypt_key'
            };
            var data = '5ADZMJYM2EMFL';
            var expectedResponse = '2027531847140704400';
            // ObjectIDEncryptor_config.type = 'PLAIN';
            var response = kmClient.ObjectIdDecrypt(data, ObjectIDEncryptor_config);
            assert.equal(response, expectedResponse);
            next();
        });

        describe('negative testcases', function() {
            it('getNetStringLength', function() {
                assert(testUtils.getNetStringLength('undefined') === 0);
                assert(testUtils.getNetStringLength(null) === 0);
                assert(testUtils.getNetStringLength(98) === 0);
                assert(testUtils.getNetStringLength("345*") === 0);
                assert(testUtils.getNetStringLength("123:") === 123);
            });
            it('aes128-decrypt-operation-wrongKeyInput', function(next) {
                console.time('aes128-decrypt-operation-wrongKeyInput');
                var requestObject = {
                    keyId: 'encrypted_cookie_bag_crypt_wrong_key',
                    data: ['VwnxfM1khPO6dJSOw+5DBEbdE2DijQP149Kw4wV5DgDS52Av5O1/NqtVPcCJwR91'],
                    isPKCS7: false
                };
                //Make the TCP call using NetString Protocol
                kmClient.decrypt(requestObject, function(error, res) {
                    assert(error, 'Error Expected');
                    assert(res.response_code === 400);
                    var expectedErrorMsg = "Could not find encrypted_cookie_bag_crypt_wrong_key in secretkeys";	
                    console.log(error.error_msg);
                    assert(contains(error.error_msg, expectedErrorMsg), 'Does not contain expected string in error message');
                    console.log('*** aes128-decrypt-operation-wrongKeyInput-test ***', error, res);
                    console.timeEnd('aes128-decrypt-operation-wrongKeyInput');
                    next();
                });
            });
            it('des-encrypt-operation-wrongEncodedInput', function(next) {
                console.time('des-encrypt-operation-wrongEncodedInput');
                var requestObject = {
                    keyId: 'encrypted_test_cryptutil_crypt_key',
                    data: ["YWJjZGdoYn="],
                    isPKCS7: false
                };
                kmClient.encrypt(requestObject, function(error, res) {
                    assert(error, 'Error Expected');
                    assert(res.response_code === 400);
                    var expectedErrorMsg = "input must be multiple of DES blocksize (8 bytes)";
                    assert(contains(error.error_msg, expectedErrorMsg), 'Does not contain expected string in error message');
                    console.log('*** des-encrypt-operation-wrongEncodedInput-test ***', error, res);
                    console.timeEnd('des-encrypt-operation-wrongEncodedInput');
                    next();
                });
            });
            it('encrypt-operation-withoutKeyId', function(next) {
                console.time('encrypt-operation-withoutKeyId');
                var requestObject = {
                    data: ["YWJjZGdoYn="],
                    isPKCS7: false
                };
                try {
                    kmClient.encrypt(requestObject, function(error, res) {
                        assert(!res, 'exception is expected instead of response');
                        next();
                    });
                } catch (ex) {
                    assert(ex, 'Error Expected');
                    // assert(contains(JSON.stringify(ex),'AssertionError'), 'Expected: AssertionError');
                    // assert(contains(JSON.stringify(ex),'keyId/s is required, please check api usage'), 'Expected Msg:  keyId/s is required, please check api usage');
                    console.timeEnd('encrypt-operation-withoutKeyId');
                    next();
                    return;
                }
            });
            it('seal-operation-without-cryptKeyId-And-macKeyId', function(next) {
                console.time('seal-operation-without-cryptKeyId-And-macKeyId');
                var requestObject = {
                    data: [base64.encode('arunkumar').toString(), "YWJjZGdoYnk="]
                };
                try {
                    kmClient.seal(requestObject, function(error, res) {
                        assert(!res, 'exception is expected instead of response');
                        next();
                    });
                } catch (ex) {
                    assert(ex, 'Error Expected');
                    //assert(contains(JSON.stringify(ex),'AssertionError'), 'Expected: AssertionError');
                    // assert(contains(JSON.stringify(ex),'keyId/s is required, please check api usage'), 'Expected Msg:  keyId/s is required, please check api usage');
                    console.timeEnd('seal-operation-without-cryptKeyId-And-macKeyId');
                    next();
                    return;
                }
            });
            it('seal-operation-with-cryptKeyId-And-without-macKeyId', function(next) {
                console.time('seal-operation-with-cryptKeyId-And-without-macKeyId');
                var requestObject = {
                    cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
                    data: [base64.encode('arunkumar').toString(), "YWJjZGdoYnk="]
                };
                try {
                    kmClient.seal(requestObject, function(error, res) {
                        assert(!res, 'exception is expected instead of response');
                        next();
                    });
                } catch (ex) {
                    assert(ex, 'Error Expected');
                    //assert(contains(JSON.stringify(ex),'AssertionError'), 'Expected: AssertionError');
                    //assert(contains(JSON.stringify(ex),'keyId/s is required, please check api usage'), 'Expected Msg:  keyId/s is required, please check api usage');
                    console.timeEnd('seal-operation-with-cryptKeyId-And-without-macKeyId');
                    next();
                    return;
                }
            });
            it('passing-pkcs7-property-for-secretproviderapi', function(next) {
                console.time('passing-pkcs7-property-for-secretproviderapi');
                var requestObject = {
                    keyId: 'encrypted_keymaker_agent_passphrase',
                    isPKCS7: true
                };
                kmClient.getSecret(requestObject, function(error, res) {
                    assert(error, 'Error object expected');
                    assert(res.response_code === 500);
                    var expectedErrorMsg = "got an unexpected keyword argument";
                    assert(contains(error.error_msg, expectedErrorMsg), "Expected String: got an unexpected keyword argument");
                    console.timeEnd('passing-pkcs7-property-for-secretproviderapi');
                    next();
                });
            });

            it('passing-dataparam-as-buffer-for-decryptAPI', function(next) {
                var requestObject = {
                    keyId: 'encrypted_test_cryptutil_crypt_key',
                    data: new Buffer('arunkumar'),
                    isPKCS7: false
                };
                kmClient.decrypt(requestObject, function(error, res) {
                    assert(error, 'Error object expected');
                    assert(!res, 'No response expected');
                    console.log(error);
                    var expectedErrorMsg = "Input Invalid - request object param 'data' should be string";
                    assert(contains(JSON.stringify(error), expectedErrorMsg), "expected string needs to be in the callback");
                    console.log(JSON.stringify(error));
                    next();
                });
            });
            it('passing-dataparam-as-buffer-for-unsealAPI', function(next) {
                var requestObject = {
                    cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
                    macKeyId: 'encrypted_test_cryptutil_mac_key',
                    data: new Buffer('arunkumar')
                };
                kmClient.unseal(requestObject, function(error, res) {
                    assert(error, 'Error object expected');
                    assert(!res, 'No response expected');
                    console.log(error);
                    var expectedErrorMsg = "Input Invalid - request object param 'data' should be string";
                    assert(contains(JSON.stringify(error), expectedErrorMsg), "expected string needs to be in the callback");
                    console.log(JSON.stringify(error));
                    next();
                });
            });

            it('cryptoserv-encrypt-decrypt-operation', function(next) {
                var requestObject = {
                    keyId: '101',
                    data: new Buffer('05940893650789087'),
                    isPKCS7: false
                };
                console.time('cryptoserv-encrypt-decrypt-operation');
                kmClient.encrypt(requestObject, function(error, res) {
                    if (perfTest) {
                        assert(!error, 'No error');
                        assert(res.response_code === 200);
                        assert(res.result);
                        assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                    }
                    console.log('*** cryptoserv-encrypt-decrypt-operation-test : ENCRYPT ***', error, res);

                    requestObject = {
                        keyId: '101',
                        data: res.result.encodedData,
                        isPKCS7: false
                    };

                    kmClient.decrypt(requestObject, function(error, res) {
                        if (perfTest) {
                            assert(!error, 'No error');
                            assert(res.response_code === 200);
                            assert(res.result);
                        }
                        console.log('*** cryptoserv-encrypt-decrypt-operation-test : DECRYPT ***', error, res);
                        console.timeEnd('cryptoserv-encrypt-decrypt-operation');
                        assert(base64.decode(res.result.encodedData).toString() === '05940893650789087', 'expected to be equal');
                        assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                        assert(res.result.plainData.toString() === '05940893650789087', 'expected to be equal');
                        
                        next();
                    });
                });
            });

            it('cryptoserv-encrypt-decrypt-106-operation', function(next) {
                var requestObject = {
                    keyId: '106',
                    data: new Buffer('05940893650789087'),
                    isPKCS7: false
                };
                console.time('cryptoserv-encrypt-decrypt-106-operation');
                    kmClient.encrypt(requestObject, function(error, res) {
                        if (perfTest) {
                            assert(!error, 'No error');
                            assert(res.response_code === 200);
                            assert(res.result);
                        }
                        console.log('*** cryptoserv-encrypt-decrypt-operation-106-test : ENCRYPT ***', error, res);

                        requestObject = {
                            keyId: '106',
                            data: res.result.encodedData,
                            isPKCS7: false
                        };

                        kmClient.decrypt(requestObject, function(error, res) {
                            if (perfTest) {
                                assert(error, 'Error: ' + error);
                                assert(!res, 'No response');
                            }
                            console.log('*** cryptoserv-encrypt-decrypt-106-operation-test : DECRYPT ***', error, res);
                            console.timeEnd('cryptoserv-encrypt-decrypt-106-operation');       
                            assert(error.error_code === 22, 'CRYPTOSERV_UNAUTHORIZED_APP_CTX');
                            next();
                        });
                    });
            });

            it('cryptoserv-cc-number-encrypt-decrypt-operation', function(next) {
                // Maximum 19 digit value
                var cc_number_string = '9999999999999999999';
                // Record time before getting PayPal Transformed CC Number
                console.time('cryptoserv-cc-number-encrypt-decrypt-operation');

                var requestObject = {
                    keyId: '101',
                    data: KeyMakerClient.getPayPalTransformedCCnumberBytes(cc_number_string),
                    isPKCS7: false
                };
                
                try {
                    kmClient.encrypt(requestObject, function(error, res) {
                        console.log(res);
                        if (perfTest) {
                            assert(!error, 'No error' + JSON.stringify(error));
                            assert(res.response_code === 200);
                            assert(res.result);
                            assert(typeof res.result.encodedData === 'string', 'encrypt api output expected to be a string');
                        }
                        console.log('*** cryptoserv-cc-number-encrypt-decrypt-operation-test : ENCRYPT ***', error, res);

                        requestObject = {
                            keyId: '101',
                            data: res.result.encodedData,
                            isPKCS7: false
                        };

                        kmClient.decrypt(requestObject, function(error, res) {
                            if (perfTest) {
                                assert(!error, 'No error');
                                assert(res.response_code === 200);
                                assert(res.result);
                            }
                            console.log('*** cryptoserv-cc-number-encrypt-decrypt-operation-test : DECRYPT ***', error, res);
                            console.timeEnd('cryptoserv-cc-number-encrypt-decrypt-operation');
                            assert(KeyMakerClient.revertPayPalTransformedCCnumberBytes(base64.decode(res.result.encodedData)) === cc_number_string, 'expected to be equal');
                            assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                            assert(KeyMakerClient.revertPayPalTransformedCCnumberBytes(res.result.plainData) === cc_number_string, 'expected to be equal');
                            
                            next();
                        });
                    });
                } catch(err) {
                        return next(err);
                }
            });

            it('cryptoserv-cc-number-encrypt-decrypt-101-operation', function(next) {
                // Maximum 19 digit value
                var cc_number_string = '9999999999999999999';
                // Record time before getting PayPal Transformed CC Number
                console.time('cryptoserv-cc-number-encrypt-decrypt-101-operation');

                var requestObject = {
                    keyId: '101',
                    data: KeyMakerClient.getPayPalTransformedCCnumberBytes(cc_number_string),
                    isPKCS7: false
                };
                
                try {
                    kmClient.encrypt(requestObject, function(error, res) {
                        console.log('*** cryptoserv-cc-number-encrypt-decrypt-101-operation-test : ENCRYPT ***', error, res);
                        assert(!error, 'No error');
                        assert(res, 'Response for encrypt');
                        requestObject = {
                            keyId: '101',
                            data: res.result.encodedData,
                            isPKCS7: false
                        };

                        kmClient.decrypt(requestObject, function(error, res) {
                            assert(!error, 'No error');
                            assert(res, 'Response for decrypt');                            
                            console.log('*** cryptoserv-cc-number-encrypt-decrypt-101-operation-test : DECRYPT ***', error, res);
                            console.timeEnd('cryptoserv-cc-number-encrypt-decrypt-101-operation');
                            assert(KeyMakerClient.revertPayPalTransformedCCnumberBytes(base64.decode(res.result.encodedData)) === cc_number_string, 'expected to be equal');
                            assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                            assert(KeyMakerClient.revertPayPalTransformedCCnumberBytes(res.result.plainData) === cc_number_string, 'expected to be equal');
                            
                            next();
                        });
                    });
                } catch(err) {
                        return next(err);
                }
            });           

            it('cryptoserv-hmac-operation', function(next) {
                console.time('cryptoserv-hmac-operation');
                var requestObject = {
                    keyId: '101',
                    data: new Buffer('12345678')
                };
                try {
                    kmClient.hmac(requestObject, function(error, res1) {
                        if (perfTest) {
                            assert(!error, 'No error');
                            assert(res1.response_code === 200);
                            assert(res1.result);
                        }
                        console.log('*** cryptoserv-hmac-operation-test : RUN 1 ***', error, res1);

                        kmClient.hmac(requestObject, function(error, res2) {
                            if (perfTest) {
                                assert(!error, 'No error');
                                assert(res2.response_code === 200);
                                assert(res2.result);
                                assert(res2.result.encodedData === res1.result.encodedData, 'expected to be equal');
                            }
                            console.log('*** cryptoserv-hmac-operation-test : RUN 2 ***', error, res2);
                            console.timeEnd('cryptoserv-hmac-operation');
                            next();
                        });
                    });
                } catch(err) {
                    return next(err);
                }
            });

            it('cryptoserv-compatibility-encrypt-java-decrypt-node', function(next) {
                var requestObject = {
                    keyId: '101',
                    data: 'ABcK1Q6BJqs09EM7Qk0F/5biIroxS8PFNYq/Aqxqe19bfh8FaQ/qx6PzqNofVpIuJM/q+q2/Pg==',
                    isPKCS7: false
                };
                console.time('cryptoserv-compatibility-encrypt-java-decrypt-node');
                kmClient.decrypt(requestObject, function(error, res) {
                    if (perfTest) {
                        assert(!error, 'No error');
                        assert(res.response_code === 200);
                        assert(res.result);
                    }
                    console.log('*** cryptoserv-compatibility-encrypt-java-decrypt-node-test ***', error, res);
                    console.timeEnd('cryptoserv-compatibility-encrypt-java-decrypt-node');
                    assert(base64.decode(res.result.encodedData).toString() === 'compatibility test #101', 'expected to be equal');
                    assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                    assert(res.result.plainData.toString() === 'compatibility test #101', 'expected to be equal');
                    next();
                });
            });

            it('cryptoserv-compatibility-cc-number-encrypt-java-decrypt-node', function(next) {
                var requestObject = {
                    keyId: '101',
                    data: 'ABcK1eIt2ikrWPtiQEqCk7cHAMhBLKOv1oH0C4GwhEEUFFTzyLlaAw==',
                    isPKCS7: false
                };
                console.time('cryptoserv-compatibility-encrypt-java-decrypt-node');
                kmClient.decrypt(requestObject, function(error, res) {
                    if (perfTest) {
                        assert(!error, 'No error');
                        assert(res.response_code === 200);
                        assert(res.result);
                    }
                    console.log('*** cryptoserv-compatibility-encrypt-java-decrypt-node-test ***', error, res);
                    console.timeEnd('cryptoserv-compatibility-encrypt-java-decrypt-node');
                    assert(KeyMakerClient.revertPayPalTransformedCCnumberBytes(base64.decode(res.result.encodedData)) === '3618796621367783707', 'expected to be equal');
                    assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
                    assert(KeyMakerClient.revertPayPalTransformedCCnumberBytes(res.result.plainData) === '3618796621367783707', 'expected to be equal');
                    next();
                });
            });

            it('cryptoserv-getPayPalTransformedCCnumberBytes-negative', function(next) {
                // Should throw erro for this 20 digit number
                var cc_number_string = '10000000000000000000';
                var exceptionOccured = false;

                try {
                    KeyMakerClient.getPayPalTransformedCCnumberBytes(cc_number_string);
                } catch(error) {
                    // Expected to come here
                    exceptionOccured = true;
                    console.log('This error is expected and has occured ' + error);
                }
                assert(exceptionOccured, 'Operation was supposed to fail: Expected exception');
                next();
            });

            it('cryptoserv-compatibility-match-hmac-from-java-with-node', function(next) {
                console.time('cryptoserv-compatibility-match-hmac-from-java-with-node');
                var requestObject = {
                    keyId: '101',
                    data: new Buffer('compatibility test #101')
                };
                kmClient.hmac(requestObject, function(error, res) {
                    if (perfTest) {
                        assert(!error, 'No error');
                        assert(res.response_code === 200);
                        assert(res.result);
                        assert(res.result.encodedData === 'oIAm0dlUysEhdX5q7amlyqgpg1Y=', 'expected to be equal');
                    }
                    console.log('*** cryptoserv-compatibility-match-hmac-from-java-with-node-test ***', error, res);
                    console.timeEnd('cryptoserv-compatibility-match-hmac-from-java-with-node');
                    next();
                });
            });

            after('keymaker shutdown', function(next) {
                KeyMakerClient.shutdown();
                next();
            });
        });
    }
});