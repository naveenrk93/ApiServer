/**
 * Created by klakhwani on 11/8/16.
 */
'use strict';
var assert = require('assert');
var cal = require('cal');
var freshy = require('freshy');
var topos = require('topos');
var nconf = require('nconf');
var base64 = require('base64-paypal');
var KeyMakerClient = require('../index');
cal.setDefaultWriteStream('console');
var kmClient;

describe('JWE and JWS testing', function() {
    before('test-setup', function(next) {
        // Unload the keymakerclient module and reload it afresh
        // else create can't be made with different parameters
        var unloaded = freshy.unload('../index');
        console.log('Unloaded=' + unloaded);
        KeyMakerClient = require('../index');
        this.timeout(20000);
        process.env.SHARE_PWD = 'aardvark';
        var opt = {};
        opt.appname = 'keymakerapiclientnodeapp';
        opt.unitTest = true;

        // Initialize topo
        topos.init(nconf.get('topos'), nconf);

        KeyMakerClient.create(opt, function(err, obj) {
            if (err) {
                console.log('client-tests err obj: ' + err);
            }
            kmClient = obj;
            next();
        });
    });

    it('JWE Encrypt + Decrypt', function(next) {
        var params = {};
        params.alg = 'RSA1_5';
        params.enc = 'A256GCM';
        params.keyId = 'mykey_1_2';
        params.thumbprintHash = 'x5t#S256';
        params.input = 'thisisasample';
        kmClient.jweEncrypt(params, function (error, result) {
            if(error) {
                console.log('Error: ' + error);
            } else {
                // console.log('*** Decode protectedHeader: ', base64.decode(result.protected, base64.CharacterSet.URLSAFE, false).toString());
                console.log('*** Plaintext to encrypt: ', params.input);
                // console.log('*** Encrypt: ' + JSON.stringify(result));
                params.input = result;
                kmClient.jweDecrypt(params, function (err, res) {
                    if(err) {
                        console.log('Error: ' + err);
                    } else {
                        // console.log('*** Decrypt: ' + JSON.stringify(res));
                        console.log('*** Plaintext after decryption: ' + (res.plaintext).toString());
                        assert((res.plaintext).toString() === 'thisisasample', 'Plaintext should be thisisasample');
                    }
                    next();
                });
            }
            
        });
    });

    it('JWS Sign + Verify', function (next) {
        var params = {};
        params.alg = 'RSA1_5';
        params.keyId = 'kafka_test_topic';
        params.input = 'thisisasample';
        kmClient.jwsSign(params, function (err, res) {
            if(err) {
                console.log('Error: ', err);
            } else {
                //console.log('*** Payload to sign: ', params.input);
                //console.log('*** Sign: ', res);
                params.input = res;
                kmClient.jwsVerify(params, function (error, result) {
                   if(error) {
                       console.log('Error: ', error);
                   } else {
                       //console.log('*** Verify: ', JSON.stringify(result));
                       //console.log('*** Payload after verification: ', (result.payload).toString());
                       assert((result.payload).toString() === 'thisisasample', 'Payload should be thisisasample');
                   }
                   next();
                });
            }
            
        });
    });
    it('JWS Sign + Verify RFC', function (next) {
        var params = {};
        params.alg = 'RSA1_5';
        params.keyId = 'kafka_test_topic';
        params.input = 'thisisasample';
        kmClient.jwsRFCSign(params, function (err, res) {
            if(err) {
                console.log('Error: ', err);
            } else {
                //console.log('*** Payload to sign: ', params.input);
                //console.log('*** Sign: ', res);
                params.input = res;
                kmClient.jwsVerify(params, function (error, result) {
                   if(error) {
                       console.log('Error: ', error);
                   } else {
                       //console.log('*** Verify: ', JSON.stringify(result));
                       //console.log('*** Payload after verification: ', (result.payload).toString());
                       assert((result.payload).toString() === 'thisisasample', 'Payload should be thisisasample');
                   }
                   next();
                });
            }
            
        });
    });


    it('JWE Cryptoserv decrypt', function (next) {
        var encryptOpts = {};
        encryptOpts.data = new Buffer('1234567890123456'); 
        encryptOpts.keyId = '101';
        kmClient.encrypt(encryptOpts, function (error, result) {
            if(error) {
                console.log('Error: ' + error);
            } else {
                var encryptedJWE;
                encryptedJWE = KeyMakerClient.cryptoservToJWE(base64.decode(result.result.encodedData), encryptOpts.keyId);
                kmClient.jweDecrypt(encryptedJWE,function (error, result) { 
                    if(error) {
                        console.log('Error: ' + JSON.stringify(error));
                    } else {
                        //console.log('*** Decrypt: ' + JSON.stringify(result));
                        //console.log('*** Plaintext after decryption: ' + (result.result.plainData).toString());
                        assert((result.result.plainData).toString() === '1234567890123456', 'Plaintext should be 1234567890123456');
                    }
                    next();
                });
            }
        });
    });

    it('JWE Cryptoserv decrypt compatibility with Raptor', function (next) {
        var encryptedJWE = 'eyJraWQiOiIxMjAiLCJlbmMiOiJDcnlwdG9TZXJ2IiwiYWxnIjoiZGlyIn0...ABcSQSNnkkLDcR6LpC_KW_cdG78lHQs7_KYBlYIqAv9JAYpmZkLcVQ.';
        kmClient.jweDecrypt(encryptedJWE,function (error, result) { 
            if(error) {
                console.log('Error: ' + JSON.stringify(error));
            } else {
                //console.log('*** Decrypt: ' + JSON.stringify(result));
                //console.log('*** Plaintext after decryption: ' + (result.result.plainData).toString());
                assert((result.result.plainData).toString() === '20180220', 'Plaintext should be 20180220');
            }
            next();
            });
        });

        after('keymaker shutdown', function(next) {
            KeyMakerClient.shutdown();
            next();
        });
    });