var assert = require('assert');
var freshy = require('freshy');
var KeyMakerClient;
var kmClient;

var topos = require('topos');
var nconf = require('nconf');
var cal = require('cal');
var connPooling = false;
var RUNS = 50;
cal.setDefaultWriteStream('console');
describe('Cryptoserv parallel requests testing', function() {
    beforeEach('test-setup', function(next) {
        // Unload the keymakerclient module and reload it afresh
        // else create can't be made with different parameters
        var unloaded = freshy.unload('../index');
        console.log('Unloaded=' + unloaded);
        KeyMakerClient = require('../index');
        this.timeout(20000);
        process.env.SHARE_PWD = 'aardvark';
        var opt = {};
        if (connPooling) {
            opt.csMinConn = 1;
        }
        opt.appname = 'keymakerapiclientnodeapp';
                
        // Initialize topo
        topos.init(nconf.get('topos'), nconf);
        opt.unitTest = true;
        KeyMakerClient.create(opt, function(err, obj) {
            if (err) {
                console.log('client-tests err obj: ' + err);
            }
            next();
        });
    });
    it("encrypt/decrypt with connection pooling OFF", function(next){
        this.timeout(30000);
        var count = 0;
        kmClient = KeyMakerClient.getClient();
        for(var i = 1; i <= RUNS; i++) {
        var kmObj = {
            keyId: "101",
            data: new Buffer("1234567890")
        };
        kmClient.encrypt(kmObj, function(error, response){
            if(error) {
                console.log("Error in encryption: ", error);
                count++;
                if (count == RUNS) {
                    connPooling = true;
                    return next();
                }
                return;
            }
            kmObj.data = new Buffer(response.result.encodedData);
            kmClient.decrypt(kmObj, function(err, res){
                count++;
                if (err) {
                    console.log("Error in decryption: ", err);
                } else {
                    assert(res.result.plainData.toString() === '1234567890', "result should match expected data" );
                }
                if (count == RUNS) {
                    connPooling = true;
                    return next();
                }
            })
        });
    }
});

it("encrypt/decrypt with connection pooling ON", function(next){
    this.timeout(30000);
    var count = 0;
    kmClient = KeyMakerClient.getClient();
    for(var i = 1; i <= RUNS; i++) {
    var kmObj = {
        keyId: "101",
        data: new Buffer("1234567890")
    };
    kmClient.encrypt(kmObj, function(error, response){
        if(error) {
            console.log("Error in encryption: ", error);
            count++;
            if (count == RUNS)
                return next();
            return;
        }
        kmObj.data = new Buffer(response.result.encodedData);
        kmClient.decrypt(kmObj, function(err, res){
            count++;
            if (err) {
                console.log("Error in decryption: ", err);
            } else {
                assert(res.result.plainData.toString() === '1234567890', "result should match expected data" );
            }
            if (count == RUNS)
                return next();
        });
    });
}
});

afterEach('Keymaker shutdown', function(next) {
    KeyMakerClient.shutdown();
    next();
})
});