'use strict';
var assert = require('assert');
var cal = require('cal');
var confit = require('confit');
var freshy = require('freshy');
var https = require('https');
var KeyMakerClient = require('../index');
var vault = require('vault');

var kmClient;
var globalConfig;

cal.setDefaultWriteStream('console');

describe('externalConnectionTests', function() {
    // setting up vault
    before('test-setup', function(next) {
        this.timeout(30000);
        // mock set up a config object like the one in paypalize or brogan
        // with ca data populated well ahead
        confit().create(function (err, config) {
            if (err) {
                console.log('sslExternalConnection test: error in confit.create: ', err);
            }
            vault.create({}, function(err, pkg) {
                if (err) {
                    console.log('sslExternalConnection test: error in vault.create: ', err);
                }
                var services = {};
                var credentials = pkg.getClientCredentials();
                services.servicecore = {
                    ca : credentials.ca,
                    key : credentials.key,
                    passphrase: credentials.passphrase,
                    cert: credentials.cert
                };
                config.set('services', services);
                globalConfig = config;

                // go ahead with keymaker init
                process.env.SHARE_PWD = 'aardvark';
                var opt = {};
                opt.appname = 'keymakerapiclientnodeapp';
                opt.unitTest = true;
                // Unload the keymakerclient module and reload it afresh
                // else create can't be made with different parameters
                var unloaded = freshy.unload('../index');
                console.log('Unloaded=' + unloaded);
                KeyMakerClient = require('../index');

                KeyMakerClient.create(opt, function(err, obj) {
                    if (err) {
                        console.log('client-tests err obj: ' + err);
                    }
                    if (obj) {
                        var trustedCerts = obj.getAllTrustedCerts();
                        if (!trustedCerts) {
                            console.log('initKeyMaker: keymaker trustedstore merge unsuccessful.');
                        }
                        else {
                            config.get('services').servicecore.ca = trustedCerts;
                            console.log('TrustStore Consolidation Successful');
                        }
                    }
                    kmClient = obj;
                    // console.log(services.servicecore.ca.toString());
                    next();
                });
            });
        });
    });

    // merchantcashadvanceserv_bml_client_keystore has been added to 'keymakerapiclientnodeapp' in keymakerUI.
    // But this should not modify the global config with its keystore because merchantcashadvanceserv_bml_client_keystore
    // has a private key entry.
    it('testConn-with-keystoreContainingPrivateKey-GlobalConfigNotModifiedAtStartUP-shouldFail', function(next) {
      this.timeout(3000);      
      //console.log(globalConfig.get('services').servicecore.ca.toString());
      var options = {
        hostname: 'developer.paypal.com',
        port: 443,
        path: '/signin',
        method: 'GET',
        ca: globalConfig.get('services').servicecore.ca,
        rejectUnauthorized: true
      };

      var req = https.request(options, function (res) {
        //assert(res.statusCode === 200, 'status code expected to be 200');
        assert(!res, 'response is not expected');

        res.on('data', function (d) {
          process.stdout.write(d);
        });

        res.on('end', function () {
          next();
        });

      });

      req.end();

      req.on('error', function (e) {
        console.error(e);
        //assert.fail(e, undefined, 'Error was not expected', '###');
        assert(e, 'Error is expected');
        next();
      });

    });

    // The googleapi_client_keystore has been added for 'keymakerapiclientnodeapp' in the keymakerweb UI.
    // This keystore doesnt have private keys but has only trusted certs and hence global config should be
    // modified and ssl external connection should go thorugh fine.
    it('testConn-with-keystoreWithoutPrivateKey-GlobalConfigModifiedAtStartUP-shouldPass', function(next) {
      this.timeout(5000);      
      //console.log(globalConfig.get('services').servicecore.ca.toString());
      var options = {
        hostname: 'encrypted.google.com',
        ca: globalConfig.get('services').servicecore.ca,
        rejectUnauthorized: true
      };

      var req = https.request(options, function (res) {
        assert(res.statusCode === 200, 'status code expected to be 200');
        assert(res, 'response is expected');

        res.on('data', function (d) {
          assert(d, 'data should be present in response');
        });

        res.on('end', function () {
          next();
        });

      });

      req.end();

      req.on('error', function (e) {
        console.error(e);
        assert.fail(e, undefined, 'Error was not expected', '###');
        next();
      });

    });

    it('getOutBoundExternalSSLConfig-local keystore', function(next) {
        var requestObject = {
            keyId: 'merchantcashadvanceserv_bml_client_keystore'
        };
        console.time('localcacheaccess');
        kmClient.getOutBoundExternalSSLConfig(requestObject, function(error, res) {
            assert(!error, 'No Error is expected');
            assert(res, 'response cannot be null');
            assert(res.server_info === 'LocalKeyMakerCache', 'should be local internal cache');
            assert(res.result.protocolVer === 'TLSv1', 'should be TLSv1');
            assert(res.result.cipherSuites, 'should have cipherSuites');
            assert(res.result.privateKey, 'should have privateKey');
            assert(res.result.publicCerts, 'should have publicCerts');
            assert(res.result.trustedCerts, 'should have trustedCerts');
            console.timeEnd('localcacheaccess');
            //console.log('*** getOutBoundExternalSSLConfig-operation-test ***', error, res);
            next();
        });
    });

    it('getOutBoundExternalSSLConfig-agentOnly keystore', function(next) {
        var requestObject = {
            keyId: 'mockprocessor_agent_only_keystore'
        };
        kmClient.getOutBoundExternalSSLConfig(requestObject, function(error, res) {
            assert(!error, 'No Error is expected');
            assert(res, 'response cannot be null');
            assert(res.server_info !== 'LocalKeyMakerCache', 'should not be local internal cache');
            assert(res.result.protocolVer === 'TLSv1', 'should be TLSv1');
            assert(res.result.cipherSuites, 'should have cipherSuites');
            assert(res.result.privateKey, 'should have privateKey');
            assert(res.result.publicCerts, 'should have publicCerts');
            assert(res.result.trustedCerts, 'should have trustedCerts');
            // console.log('*** getOutBoundExternalSSLConfig-operation-test ***', error, res);
            next();
        });
    });
    // This should error out
    it('getOutBoundExternalSSLConfig-nosuchkeystore', function(next) {
        var requestObject = {
            keyId: 'non_existing_keystore'
        };
        kmClient.getOutBoundExternalSSLConfig(requestObject, function(error, res) {
            assert(error, 'Error is expected');
            assert(!res, 'response to be null');
            // console.log('*** getOutBoundExternalSSLConfig-operation-test ***', error, res);
            next();
        });
    });

    // This should return back the vault keystore
    it('getOutBoundExternalSSLConfigFromVault', function(next) {
        var vaultSSLConfig = kmClient.getOutBoundExternalSSLConfigFromVault();
        assert(vaultSSLConfig, 'vault ssl config should be returned');
        assert(vaultSSLConfig.result.trustedCerts, 'trustedCerts should be returned');
        assert(vaultSSLConfig.result.privateKey, 'privateKey should be returned');
        assert(vaultSSLConfig.result.publicCerts, 'publicCerts should be returned');
        //console.log('*** getOutBoundExternalSSLConfigFromVault-operation-test ***', vaultSSLConfig);
        next();
    });

    // merchantcashadvanceserv_bml_client_keystore has been added to 'keymakerapiclientnodeapp' and getOutBound api call
    // should give the correct SSLConfig and connection should go through fine.
    it('testConn-with-getOutBoundExternalSSLConfig-localcache_keystore', function(next) {
        this.timeout(3000); 
        var requestObject = {
            keyId: 'internal_test_client_keystore'
        };
        kmClient.getOutBoundExternalSSLConfig(requestObject, function(error, keymakerResponse) {
          var options = {
            hostname: 'developer.paypal.com',
            port: 443,
            path: '/signin',
            method: 'GET',
            key: keymakerResponse.result.privateKey,
            cert: keymakerResponse.result.publicCerts,
            ca: keymakerResponse.result.trustedCerts,
            rejectUnauthorized: true
          };

          var req = https.request(options, function (res) {
            console.log('statusCode: ', res.statusCode);
            console.log('headers: ', res.headers);
            assert(res.statusCode === 200, 'status code expected to be 200');
            assert(res, 'response expected');


            res.on('data', function (d) {
              process.stdout.write(d);
            });

            res.on('end', function () {
              next();
            });

          });

          req.end();

          req.on('error', function (e) {
            console.error(e);
            assert.fail(e, undefined, 'Error was not expected', '###');
            next();
          });

        });
    });
    after('keymaker shutdown', function(next) {
        KeyMakerClient.shutdown();
        next();
    });
});