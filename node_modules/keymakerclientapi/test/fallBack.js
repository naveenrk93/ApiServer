'use strict';
var assert = require('assert');
var base64 = require('base64-paypal');
var KeyMakerClient = require('../index');
var freshy = require('freshy');
var cal = require('cal');
cal.setDefaultWriteStream('console');
var kmClient;
var perfTest = false;
var testResultData = {};
testResultData.desEncryptOutput;
testResultData.aes128EncryptOutput;
testResultData.aes256EncryptOutput;
testResultData.sealdesxsha1Output;


describe('fallback-testing', function() {
    // setting up vault
    before('create keymakerclient object first time', function(next) {
        // Unload the keymakerclient module and reload it afresh
        // else create can't be made with different parameters
        var unloaded = freshy.unload('../index');
        console.log('Unloaded=' + unloaded);
        KeyMakerClient = require('../index');
        
        console.time('test-setup');
        this.timeout(20000);
        process.env.SHARE_PWD = 'aardvark';
        var opt = {};
        opt.appname = 'keymakerapiclientnodeapp';
        opt.isAgentEnabled = true;
        opt.unitTest = true;
        KeyMakerClient.create(opt, function(err, obj) {
            if (err) {
                console.log('client-tests err obj: ' + err);
            }
            kmClient = obj;
            console.log(kmClient);
            console.timeEnd('test-setup');
            next();
        });
    });

    it('encrypt-operation', function(next) {
        var requestObject = {
            keyId: 'encrypted_nonexport-128_crypt_key',
            //keyId: 'encrypted_foosball_beacon_crypt_key', //offlinetesting
            data: new Buffer('arunkumaamuknura'),
            isPKCS7: false
        };
        kmClient.encrypt(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            console.log('*** encrypt-operation-test ***', error, res);
            testResultData.desEncryptOutput = res.result.encodedData;
            next();
        });
    });

    it('decrypt-operation', function(next) {
        var requestObject = {
            keyId: 'encrypted_nonexport-128_crypt_key',
            data: testResultData.desEncryptOutput,
            isPKCS7: false
        };
        kmClient.decrypt(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            console.log('*** decrypt-operation-test ***', error, res);
            assert(base64.decode(res.result.encodedData).toString() === 'arunkumaamuknura', 'should match plain text');
            assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
            assert(res.result.plainData.toString() === 'arunkumaamuknura', 'should match plain text');
            next();
        });
    });

    it('des-encrypt-operation-list to be done by agent', function(next) {
        var requestObject = {
            keyId: 'encrypted_test_cryptutil_crypt_key',
            //keyId: 'encrypted_foosball_beacon_crypt_key', //offlinetesting
            data: [new Buffer('arunkuma'), new Buffer('kumaarun'), new Buffer('testdata'), new Buffer('74686574c3a97374', 'hex')],
            isPKCS7: false
        };
        kmClient.encrypt(requestObject, function(error, res) {
            console.log('*** des-encrypt-operation-test ***', error, res);
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            console.log(res.result.encodedData);
            assert(res.result.encodedData.constructor === Array, 'response encodedData to be an Array');
            testResultData.desEncryptOutput = res.result.encodedData;
            next();
        });
    });

    it('des-decrypt-operation-list to be done by agent', function(next) {
        var requestObject = {
            keyId: 'encrypted_test_cryptutil_crypt_key',
            data: testResultData.desEncryptOutput,
            isPKCS7: false
        };
        console.time('des-decrypt-operation');
        kmClient.decrypt(requestObject, function(error, res) {
            console.log('*** des-decrypt-operation-test ***', error, res);
            console.timeEnd('des-decrypt-operation');
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.encodedData.constructor === Array, 'response encodedData to be an Array');
            assert(base64.decode(res.result.encodedData[0]).toString() === 'arunkuma', 'decrypted output is not arunkuma');
            assert(res.result.plainData[0] instanceof Buffer, 'type expected to be Buffer');
            assert(res.result.plainData[0].toString() === 'arunkuma', 'should match plain text');
            assert(res.result.plainData[1].toString() === 'kumaarun', 'should match plain text');
            assert(res.result.plainData[2].toString() === 'testdata', 'should match plain text');
            assert(res.result.plainData[3].toString() === 'thet√©st', 'should match plain text');
            assert(res.result.plainData[3].toString('hex') === '74686574c3a97374', 'should match plain text');
            next();
        });
    });

    it('asymmetric-encrypt-operation single input single output to be done by agent', function(next) {
        var requestObject = {
            keyId: 'mykey3',
            data: new Buffer('arunkumar'),
            isPKCS7: false
        };
        //Make the TCP call using NetString Protocol
        kmClient.encrypt(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.keyId === requestObject.keyId);
            assert(res.result.encodedData.constructor !== Array, 'response encodedData to be a string');
            testResultData.asymencryptOp = res.result.encodedData;
            console.log('*** asymmetric-encrypt-operation-test ***', error, res);
            next();
        });
    });

    it('asymmetric-decrypt-operation single input single output to be done by agent', function(next) {
        var requestObject = {
            keyId: 'mykey3',
            data: testResultData.asymencryptOp,
            isPKCS7: false
        };
        //Make the TCP call using NetString Protocol
        kmClient.decrypt(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.keyId === requestObject.keyId);
            assert(res.result.encodedData.constructor !== Array, 'response encodedData to be a string');
            assert(base64.decode(res.result.encodedData).toString() === 'arunkumar', 'decrypted value should match');
            assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
            assert(res.result.plainData.toString() === 'arunkumar', 'decrypted value should match');
            console.log('*** asymmetric-decrypt-operation-test ***', error, res);
            next();
        });
    });

    it('rsa-sign-operation single input single single output to be done by agent', function(next) {
        var requestObject = {
            keyId: 'mykey3',
            data: new Buffer('arunkumar'),
            isPKCS7: false
        };
        //Make the TCP call using NetString Protocol
        kmClient.sign(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.keyId === requestObject.keyId);
            testResultData.rsaSignOp = res.result.encodedData;
            console.log('*** rsa-sign-operation-test ***', error, res);
            next();
        });
    });

    it('rsa-verify-operation single input single output to be done by agent', function(next) {
        var requestObject = {
            keyId: 'mykey3',
            data: new Buffer('arunkumar'),
            signed: testResultData.rsaSignOp
        };
        //Make the TCP call using NetString Protocol
        kmClient.verify(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.keyId === requestObject.keyId);
            assert(res.result.isVerified === true, 'isVerified to be true');
            console.log('*** rsa-verify-operation-test ***', error, res);
            next();
        });
    });

    it('hmac-operation', function(next) {
        console.time('hmac-operation');
        var requestObject = {
            keyId: 'encrypted_nonexport-256_mac_key',
            data: new Buffer('12345678')
        };
        kmClient.hmac(requestObject, function(error, res) {
            if (perfTest) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
            }
            console.log('*** hmac-operation-test ***', error, res);
            console.timeEnd('hmac-operation');
            next();
        });
    });

    it('hmac-operation-list', function(next) {
        console.time('hmac-operation');
        var requestObject = {
            keyId: 'encrypted_nonexport-256_mac_key',
            data: [new Buffer('12345678')]
        };
        kmClient.hmac(requestObject, function(error, res) {
            if (perfTest) {
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
            }
            console.log('*** hmac-operation-test ***', error, res);
            console.timeEnd('hmac-operation');
            next();
        });
    });

    it('seal-operation', function(next) {
        console.time('seal-operation');
        var requestObject = {
            cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
            macKeyId: 'encrypted_test_cryptutil_mac_key',
            data: new Buffer('arunkumar')
        };
        kmClient.seal(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            console.log('*** seal-operation-test ***', error, res);
            console.timeEnd('seal-operation');
            testResultData.sealdesxsha1Output = res.result.encodedData;
            next();
        });
    });

    it('unseal-operation', function(next) {
        console.time('unseal-operation');
        var requestObject = {
            cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
            macKeyId: 'encrypted_test_cryptutil_mac_key',
            data: testResultData.sealdesxsha1Output
        };
        console.log(testResultData.sealdesxsha1Output);
        kmClient.unseal(requestObject, function(error, res) {
            assert(!error, 'No error');
            console.log('*** unseal-operation-test ***', error, res);
            console.timeEnd('unseal-operation');
            assert(res.result.plainData.toString() === 'arunkumar', 'unsealed value should match');
            assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
            assert(base64.decode(res.result.encodedData).toString() === 'arunkumar', 'encoded unsealed value should match');
            next();
        });
    });

    it('seal-operation-list to be done by agent', function(next) {
        console.time('seal-operation');
        var requestObject = {
            cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
            macKeyId: 'encrypted_test_cryptutil_mac_key',
            data: [new Buffer('arunkumar')]
        };
        kmClient.seal(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.cryptKeyId === requestObject.cryptKeyId);
            console.log('*** seal-operation-test ***', error, res);
            console.timeEnd('seal-operation');
            testResultData.sealdesxsha1Output = res.result.encodedData;
            next();
        });
    });

    it('unseal-operation-list to be done by agent', function(next) {
        console.time('unseal-operation');
        var requestObject = {
            cryptKeyId: 'encrypted_test_cryptutil_crypt_key',
            macKeyId: 'encrypted_test_cryptutil_mac_key',
            data: testResultData.sealdesxsha1Output
        };
        console.log(testResultData.sealdesxsha1Output);
        kmClient.unseal(requestObject, function(error, res) {
            assert(!error, 'No error');
            console.log('*** unseal-operation-test ***', error, res);
            console.timeEnd('unseal-operation');
            assert(base64.decode(res.result.encodedData[0]).toString() === 'arunkumar', 'encoded unsealed value should match');
            assert(res.result.plainData[0] instanceof Buffer, 'type expected to be Buffer');
            assert(res.result.plainData[0].toString() === 'arunkumar', 'plain unsealed value should match');
            next();
        });
    });

    it('secretprovider-operation', function(next) {
        console.time('secretprovider-operation');
        var requestObject = {
            // To::Do:: This key needs to be replaced with another key which is accessible only in agent
            keyId: 'encrypted_devplat_oracle_password'
        };
        kmClient.getSecret(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.keyId === requestObject.keyId);
            assert(base64.decode(res.result.encodedData).toString() === 'devplatappstg', 'expected to be equal');
            assert(res.result.plainData instanceof Buffer, 'type expected to be Buffer');
            assert(res.result.plainData.toString() === 'devplatappstg', 'expected to be equal');
            console.log('*** secretprovider-operation-test ***', error, res);
            console.timeEnd('secretprovider-operation');
            next();
        });
    });

    it('pkcs7-sign-verify-operation to be done by agent', function(next) {
        console.time('pkcs7-sign-operation');
        var requestObject = {
            keyId: 'mykey3',
            data: new Buffer('arunkumar'),
            isPKCS7: true
        };
        kmClient.sign(requestObject, function(error, res) {
            assert(!error, 'No error');
            assert(res.response_code === 200);
            assert(res.result);
            assert(res.result.keyId === requestObject.keyId);
            console.log('*** pkcs7-sign-operation-test ***', error, res);
            console.timeEnd('pkcs7-sign-operation');

            var requestObject2 = {
                keyId: 'mykey3',
                data: '',
                signed: res.result.encodedData
            }; 
            console.time('pkcs7-verify-operation');
            kmClient.verify(requestObject2, function(error, res) {
                console.log(error);
                assert(!error, 'No error');
                assert(res.response_code === 200);
                assert(res.result);
                assert(res.result.keyId === requestObject.keyId);
                assert(res.result.isVerified === true, 'isVerified to be true');
                console.log('*** pkcs7-verify-operation-test ***', error, res);
                console.timeEnd('pkcs7-verify-operation');
                next();
            });
        });
    });

    after('keymaker shutdown', function(next) {
        KeyMakerClient.shutdown();
        next();
    });

});