'use strict';

const _ = require('underscore');
const Keymakerclientapi = require('keymakerclientapi');
const ssoUtil = require('./util');
const Path2Regexp = require('path-to-regexp');
const SamlEncryptedStrategy = require('passport-saml-encrypted').Strategy;

// Default settings for the module.
const defaultSettings = {
    protocol: 'https://',
    logging: true,
    encryptedSAML: true,
    identifierFormat: 'urn:oasis:names:tc:SAML:2.0:nameid-format:transient',
    appLogin: '/login',
    samlPostback: '/saml/acs',
    flash: true
};

/**
 * setupPassport - add the encrypted SAML passport strategy to the passport
 * instance and then register serialization and deserialization strategies.
 */
function setupPassport(settings, passport) {
    // Build a new authentication strategy and pass it to passport.
    passport.use(new SamlEncryptedStrategy(settings, function (user, done) {
        done(null, user);
    }));
    passport.serializeUser(function serializeUser(user, done) {
        done(null, JSON.stringify(user));
    });
    passport.deserializeUser(function deserializeUser(serializedUser, done) {
        done(null, JSON.parse(serializedUser));
    });
}

function buildSettings(config) {
    // Override default settings from user provided settings and get the user provided root url.
    const settings = _.extend(defaultSettings, config);

    let exclude = [
        config.mountpath + defaultSettings.appLogin,
        config.mountpath + defaultSettings.samlPostback
    ];
    const confExclude = config.exclude;
    // If the user provides exclude routes, add them to the list
    if (confExclude && _.isArray(confExclude)) {
        exclude = _.union(exclude, confExclude);
    }

    // Build a single regular expression for all excluded urls
    settings.exclude = Path2Regexp(exclude);

    if (!settings.failureRedirect) {
        settings.failureRedirect = config.mountpath;
    }

    // Set up the post back url for the SAML responses
    settings.path = (config.mountpath === '/' ? '' : config.mountpath) + settings.samlPostback;
    return settings;
}

/**
 * Pull in user provided settings and configure passport and override any default
 * configurations the user may want to set.
 *
 * @param  {type} config   description
 * @param  {type} passport description
 * @return {type}          description
 */
module.exports = function configure(config, passport) {
    const calTxn = ssoUtil.createCalTransaction('SSO_PAYPAL_CONFIG', config.ssoKeyStore);

    const settings = buildSettings(config);
    calTxn.addData('settings', JSON.stringify(settings));

    // ssoKeyStore is mandatory
    if (settings.hasOwnProperty('ssoKeyStore') && settings.ssoKeyStore !== null) {
        const kmclient = Keymakerclientapi.getClient();
        const ssoRequest = {
            keyId: settings.ssoKeyStore
        };
        // Get ssoConfig from keymaker
        kmclient.getSSOConfig(ssoRequest, function (err, res) {
            if (err) {
                console.error('SSO config is unavailable');
                calTxn.status = ssoUtil.getCalStatus('error');
                calTxn.addData('getSSOConfig', 'SSO config is unavailable');
            } else {
                // set the privateKey and Cert received from keymaker
                settings.privateCert = res.result.clientPrivateKey;
                settings.cert = res.result.trustedCert;
            }
            calTxn.complete();
            // Set up the passport instance with configuration
            setupPassport(settings, passport);
        });
    } else {
        // ssoKeyStore is mandatory in this version
        // API usage has not been followed
        console.error('ssoKeyStore property does not exist OR no name is provided');
        calTxn.status = ssoUtil.getCalStatus('error');
        calTxn.addData('failure', 'ssoKeyStore property does not exist OR no name is provided');
        calTxn.complete();

        setupPassport(settings, passport);
    }

    return settings;
};
