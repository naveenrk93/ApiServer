'use strict';

const async = require('async');
const chai = require('chai');
const expect = chai.expect;
const express = require('express');
const session = require('express-session');
const _ = require('underscore');
const keymakerclientapi = require('keymakerclientapi');
const http = require('http');
const request = require('request');
const cal = require('cal');
const setCookie = require('set-cookie-parser');
const SsoPayPal = require('../');

let app, httpServer, SOCKET;

cal.setDefaultWriteStream('console');

function killServer() {
    if (httpServer) {
        httpServer.close();
    }
    if (SOCKET) {
        SOCKET.destroy();
    }
}

function getSessionCookie(res) {
    const cookies = setCookie.parse(res, {
        decodeValues: false
    });
    let cookie = '';
    cookies.forEach((c) => {
        if (c.name === 'sid') {
            cookie += `${c.name}=${c.value}`;
        }
    });
    return cookie;
}

function setup(config) {
    return  function () {
        app = express();

        app.kraken = {
            get: function () {
                return config.passphrase;
            }
        };

        app.use(session({ name: 'sid', secret: 'blah blah', cookie: { maxAge: 2211 }}));
        app.use(function (req, res, next) {
            if (req.session && req.session.user) {
                req.user = req.session.user;
            }
            next();
        });
        app.use(SsoPayPal(config.moduleConfig));
        app.use(function (req, res, next) {
            if (req.url === '/saml/acs') {
                req.session.regenerate(next);   // simulate session update
            } else {
                next();
            }
        });

        _.each(config.endpoints, function (ep) {
            app[ep.method](ep.path, function (req, res) {
                const user = ep.user || req.user || { err: 'NO USER FOUND'};
                if (ep.user) {
                    req.session.user = ep.user;
                }
                res.status(200).json(user);
            });
        });

        httpServer = http.createServer(app);
        httpServer.on('connection', function (socket) {
            SOCKET = socket;
        });

        httpServer.listen(8000);
    };
}

describe('sso', function () {

    const config = {
        endpoints: [
            {
                method: 'get',
                path: '/protected'
            },
            {
                method: 'get',
                path: '/public'
            },
            {
                method: 'get',
                path: '/saml/acs',
                user: {
                    UserName: 'paypal',
                    FirstName: 'Pay',
                    LastName: 'Pal'
                }
            }
        ],
        moduleConfig: {
            'issuer':'https://sso.paypal.com',
            'protocol': 'http://',
            'entryPoint': 'http://localhost:8000/sso',
            'ssoKeyStore': 'sso_test_keystore',
            'exclude': ['/public']
        }
    };

    before('test-setup-for-keymaker', function (next) {
        this.timeout(20000);
        process.env.SHARE_PWD = 'aardvark';
        const opt = {
            appname: 'keymakerapiclientnodeapp',
            unitTest: true
        };
        keymakerclientapi.create(opt, function (err) {
            if (err) {
                console.error('keymaker error reason- ', err);
            }
            next();
        });
    });
    before(setup(config));

    after(killServer);

    it('should leave excluded routes open', function (done) {
        request('http://localhost:8000/public', function (err, res, body) {
            expect(res.statusCode).to.equal(200);

            expect(JSON.parse(body.toString('utf8'))).to.deep.equal({
                err: 'NO USER FOUND'
            });
            done();
        });
    });

    it('should redirect to login on protected routes', function (done) {
        http.get('http://localhost:8000/protected', function (res) {
            expect(res.statusCode).to.equal(302);
            expect(res.headers.location).to.equal('/login');
            done();
        });
    });

    it('should redirect to the sso host at login', function (done) {
        http.get('http://localhost:8000/login', function (res) {
            expect(res.statusCode).to.equal(302);
            expect(res.headers.location).to.match(/^http:\/\/localhost:8000\/sso\?SAMLRequest=/);
            done();
        });
    });

    it('should change the sessionId', function (done) {
        const options = {
            baseUrl: 'http://localhost:8000/',
            method: 'GET',
            headers: {}
        }
        async.series([
            function step1(cb) {
                options.url = '/public';
                request(options, function (err, res) {
                    expect(res.statusCode).to.equal(200);
                    let cookie = getSessionCookie(res);
                    options.headers.cookie = cookie;
                    cb();
                });
            },
            function step2(cb) {
                options.url = '/saml/acs';
                request(options, function (err, res) {
                    expect(res.statusCode).to.equal(200);
                    let cookie = getSessionCookie(res);
                    expect(options.headers.cookie).to.not.equal(cookie);
                    options.headers.cookie = cookie;
                    cb();
                });
            },
            function step3(cb) {
                options.url = '/protected';
                options.followRedirect = false;
                request(options, function (err, res) {
                    let cookie = getSessionCookie(res);
                    expect(options.headers.cookie).to.equal(cookie);
                    expect(res.statusCode).to.equal(302);
                    cb();
                });
            }
        ], done);

    });

});


describe('sso for testing', function () {
    process.env.NODE_ENV = 'test';
    const config = {
        endpoints: [
            {
                method: 'get',
                path: '/protected'
            },
            {
                method: 'get',
                path: '/public'
            },
            {
                method: 'get',
                path: '/saml/acs',
                user: {
                    UserName: 'paypal',
                    FirstName: 'Pay',
                    LastName: 'Pal'
                }
            }
        ],
        moduleConfig: {
            user: {
                UserName: 'paypal',
                FirstName: 'Pay',
                LastName: 'Pal'
            }
        }
    };

    before('test-setup-for-keymaker', function (next) {
        this.timeout(20000);
        process.env.SHARE_PWD = 'aardvark';
        const opt = {
            appname: 'keymakerapiclientnodeapp',
            unitTest: true
        };
        keymakerclientapi.create(opt, function (err) {
            if (err) {
                console.error('keymaker error reason- ', err);
            }
            next();
        });
    });
    before(setup(config));

    after(killServer);

    it('should leave excluded routes open', function (done) {
        request('http://localhost:8000/public', function (err, res, body) {
            expect(res.statusCode).to.equal(200);
            expect(JSON.parse(body.toString('utf8'))).to.deep.equal(config.moduleConfig.user);
            done();
        });
    });

    it('should redirect to login on protected routes', function (done) {
        request('http://localhost:8000/protected', function (err, res, body) {
            expect(res.statusCode).to.equal(200);
            expect(JSON.parse(body.toString('utf8'))).to.deep.equal(config.moduleConfig.user);
            done();
        });
    });

});
